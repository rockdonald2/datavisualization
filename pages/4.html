<!DOCTYPE html>
<html lang="en"
    class="text-gray-800 text-base md:text-lg antialiased leading-relaxed tracking-normal break-normal bg-white">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport"
            content="width=device-width, initial-scale=1.0">
        <meta name="description"
            content="A repo for studying a book.">
        <meta name="keywords"
            content="visualization,javascript,python,d3,flask,restful">
        <meta name="author"
            content="Luk√°cs Zsolt">
        <meta http-equiv="X-UA-Compatible"
            content="ie=edge">
        <title>4 Az adatok tiszt√≠t√°sa √©s feldolgoz√°sa</title>
        <link rel="stylesheet"
            href="../css/style.css">
        <!-- Safari-n az emoji favicon nem m≈±k√∂dik -->
        <link rel="icon"
            href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22
                viewBox=%220
                0
                100
                100%22><text y=%22.9em%22
                    font-size=%2290%22>üìï</text></svg>">
    </head>

    <body class="overflow-x-hidden">
        <!-- navig√°ci√≥ -->
        <nav class="pushy pushy-left">
            <div class="pushy-content">
                <ul>
                    <li class="pushy-link"><a href="../index.html">1 Bevezet√©s</a></li>
                    <li class="pushy-link"><a href="2.html">2 Els≈ë l√©p√©sek az adatvizualiz√°ci√≥ban</a></li>
                    <li class="pushy-link"><a href="3.html">3 Az adatok megszerz√©se</a></li>
                    <li class="pushy-link"><a href="4.html">4 Az adatok tiszt√≠t√°sa √©s feldolgoz√°sa</a></li>
                </ul>
            </div>
        </nav>

        <!-- Pushy-hoz site overlay -->
        <div class="site-overlay"></div>

        <main id="container"
            class="container p-8 md:p-6 max-w-2xl md:max-w-3xl min-h-screen">
            <button id="menu"
                class="menu-btn px-4 py-2 bg-gray-900 text-white hover:bg-blue-800 transition duration-75 ease-in">&#9776;
                Men√º</button>

            <!-- negyedik r√©sze eleje -->

            <section class="pb-8">
                <h1 class="text-3xl md:text-4xl py-8 text-gray-900 font-semibold">4 Az adatok tiszt√≠t√°sa √©s feldolgoz√°sa</h1>

                <section id="4numpy">
                    <h2 class="text-2xl pb-4 font-semibold text-gray-800">Bevezet√©s a NumPy-ba</h2>
                    <p id="firstPar"
                        class="text-lg font-normal pb-3">Ebben a fejezetben egy √∫jabb Python k√∂nyvt√°rral fogunk megismerkedni, a
                        Numeric Python-al, r√∂viden a NumPy-al. A NumPy kulcsfontoss√°g√∫ lesz a Pandas-al val√≥ munka sor√°n,
                        elhagyhatatlan az
                        adat-elemz√©shez haszn√°lt k√∂nyvt√°runkhoz, amellyel az ezt k√∂vet≈ë fejezetekben fogunk megismerkedni mik√∂zben
                        a
                        nemr√©g megszerzett Nobel-d√≠j adatsorunkat tiszt√≠tjuk √©s fedezz√ºk fel. Egy √°ltal√°nos ismeret √©s tud√°s a
                        NumPy alapvet≈ë elemeir≈ël n√©lk√ºl√∂zhetetlen, ha a legt√∂bbet szeretn√©nk kinyerni a Pandas-b√≥l.</p>
                    <p class="text-lg font-normal pb-3">A NumPy egy Python m√≥dul, amely el√©rhet≈ëv√© tesz nagyon gyors,
                        t√∂bb-dimenzi√≥s t√∂mb manipul√°l√°st, mindezt a h√°tt√©rben alacsony szint≈± k√∂nyvt√°rakkal megt√°mogatva C-ben √©s
                        Fortran-ban √≠rva. A Python nat√≠v teljes√≠tm√©nye nagy mennyis√©g≈± adattal lass√∫, nagyon magas nyelv l√©v√©n, de
                        a NumPy lehet≈ëv√© tesz azt, hogy p√°rhuzamosan hajts v√©gre m≈±veleteket nagy t√∂mb√∂k√∂n egyidej≈±leg, ez √°ltal
                        nagyon gyorss√° t√©ve.</p>
                    <p class="text-lg font-normal pb-3">Mondhatni, a NumPy minden adat-feldolgoz√°si munk√°nak az alapj√°t k√©pzi, de
                        tov√°bb√° elmondhat√≥ az is, hogy maga a NumPy √∂kosziszt√©ma is rendk√≠v√ºl kiterjedt, olyan kieg√©sz√≠t≈ëkkel
                        rendelkezik, mint a SciPy, a Python tudom√°nyos m√≥dulja, amely bonyolult tudom√°nyos √©s m√©rn√∂ki m√≥dulokat
                        tartalmaz. De megeml√≠thet≈ë m√©g a Scikit-learn, amely rendelkez√©s√ºnkre bocs√°jt machine-learning
                        algoritmusokat. Azonban, az eml√≠tetteken k√≠v√ºl m√©g sz√°mos kieg√©sz√≠t≈ëvel rendelkezik a NumPy √©s szakosodott
                        k√∂nyvt√°rak is l√©teznek, amelyek a NumPy t√∂bb-dimenzi√≥s t√∂mbjeire √©p√ºlnek.</p>
                    <p class="text-lg font-normal pb-3">Amit legf≈ëk√©ppen megkell teh√°t √©rteni a NumPy-al kapcsolatosan, az nem
                        m√°s, mint a t√∂mbjei, a k√∂vetkez≈ëkben p√©ld√°kon kereszt√ºl azokat fogjuk megvizsg√°lni.</p>
                    <p class="text-lg font-normal">A NumPy-ban minden a t√∂bb-dimenzi√≥s <em>ndarray</em> objektumra √©p√ºl. Egy√©b
                        dolgok mellett, olyan egyszer≈±eket is ellehet v√©gezni ezen objektumokon, mint az aritmetikai m≈±veletek,
                        ahogy azt elemi t√≠pusok, ak√°r floatok eset√©ben is tenn√©nk. N√©zz√ºk meg ezt egy p√©ld√°n kereszt√ºl:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">import numpy as np

a = np.array([1, 2, 3])

a + a # output: array([2, 4, 6])</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Az ndarray objektum h√°rom fontos tulajdons√°ggal rendelkezik, a dimenzi√≥k sz√°ma
                        <em>(ndim)</em>, az alakja <em>(shape)</em>, v√©g√ºl a numerikus t√≠pusa <em>(numeric type)</em>. Ugyanaz a
                        t√∂mbnyi sz√°m ak√°r √°talak√≠that√≥ helyben is, amely ak√°r mag√°ba foglalhatja a t√∂mb dimenzi√≥inak sz√°m√°nak
                        megv√°ltoz√°s√°t is. A k√∂vetkez≈ë p√©lda egy ilyent helyzetet szeml√©ltet:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># ezt a f√ºggv√©nyt fogjuk haszn√°lni a 3 tulajdons√°g ki√≠r√°s√°ra
def print_array_details(a):
    print('Dimensions: {}, shape: {}, dtype: {}'.format(a.ndim, a.shape, a.dtype))

a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
print(a)
print_array_details(a)
# output:
# [1 2 3 4 5 6 7 8 9]
# Dimensions: 1, shape: (9,), dtype: int32</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Felhaszn√°lva a <em>reshape</em> met√≥dust, k√©pesek vagyunk megv√°ltoztatni az
                        alakj√°t √©s a dimenzi√≥inak sz√°m√°t az 'a' t√∂mbnek. Alak√≠tsuk √°t a jelenlegi t√∂mb√ºnket egy 3 dimenzi√≥s
                        t√∂mbb√©, amely 3 darab 3 tagb√≥l √°ll√≥ t√∂mbb≈ël √°ll:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">a = a.reshape([3, 3])
print(a)
print_array_details(a)
# [[1 2 3]
#  [4 5 6]
#  [7 8 9]]
# Dimensions: 2, shape: (3, 3), dtype: int32</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A k√∂vetkez≈ë p√©ld√°ban egy √∂sszesen 8 tagb√≥l √°ll√≥ t√∂mb h√°rom dimenzioss√° is
                        tehet≈ë:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">b = np.array([1, 2, 3, 4, 5, 6, 7, 8])
b = b.reshape([2, 2, 2])
print(b)
print_array_details(b)
# [[[1 2]
#   [3 4]]
# 
#  [[5 6]
#   [7 8]]]
# Dimensions: 3, shape: (2, 2, 2), dtype: int32</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">A fenti p√©ld√°kb√≥l m√°r √°ltal√°noss√°gban kik√∂vetkeztethet≈ë n√©h√°ny dolog.
                        Egyr√©szt,
                        a dimenzi√≥k sz√°m√°t az alakja hat√°rozza meg, illetve ahhoz, hogy egy bizonyos dimenzi√≥t bet√∂lts√∂n egy
                        t√∂mbnyi sz√°m, minimum <em>n^ndim</em> elemmel kell rendelkezzen, (n, n, n) alak eset√©n.</p>
                    <p class="text-lg font-normal">A t√∂mb alakja √©s numerikus t√≠pusa l√©trehoz√°skor is meghat√°rozhat√≥, ugyanakkor
                        l√©trehoz√°s ut√°n a legk√∂nnyebb megold√°s a t√∂mb numerikus t√≠pus√°nak megv√°ltoztat√°s√°ra a reshape-hez
                        hasonl√≥an
                        az <em>astype</em> met√≥dus lenne. Eben az esetben a met√≥dus egy √°tm√©retezett m√°solatot k√©sz√≠t az eredeti
                        t√∂mbr≈ël a mod√≥s√≠tott t√≠pussal:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">x = np.array([[1, 2, 3], [4, 5, 6]], np.int64)
print(x.shape) # output: (2, 3)
print(x.dtype) # output: int64

x.shape = (6, )
x = x.astype('int32')
print(x.shape) # output: (6, )
print(x.dtype) # output: int32</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Amellett, hogy NumPy eset√©n lehet≈ës√©g√ºnk van sz√°msorokb√≥l t√∂mb√∂ket l√©trehozni,
                        biztos√≠t j√≥n√©h√°ny kieg√©sz√≠t≈ë f√ºggv√©nyt, hogy l√©trehozzunk t√∂mb√∂t egy bizonyos mint√°val. <em>zeros</em> √©s
                        <em>ones</em> f√ºggv√©nyek p√©ldak√©ppen a leggyakrabban haszn√°ltak k√∂z√© tartoznak, amelyek el≈ëre felt√∂lt√∂tt
                        t√∂mb√∂ket hoznak l√©tre a megadott mint√°val. Fontos megjegyezni, hogy ezek a f√ºggv√©nyek √°ltal√°ban float64
                        t√≠pussal dolgoznak, √©s nem intekkel:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">a = np.zeros([2, 3])
print(a)
print(a.dtype)
# output:
# [[0. 0. 0.]
#  [0. 0. 0.]]
# float64

b = np.ones([2, 3])
print(b)
print(b.dtype)
# output:
# [[1. 1. 1.]
#  [1. 1. 1.]]
# float64</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Emellett, rendelkez√©s√ºnkre √°ll egy <em>empty</em> met√≥dus is, amely l√©trehozza
                        a sz√ºks√©ges mem√≥ria-blokkot, azonban nem t√∂lti fel azt elemekkel √©s az inicializ√°l√°st r√°nk hagyja:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">empty_arr = np.empty([2, 3])
print(empty_arr)
# output: 
# [[1. 1. 1.]
#  [1. 1. 1.]]
# az output v√°ltozhat, att√≥l f√ºgg≈ëen √©ppen mi volt a mem√≥riater√ºleten</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A k√∂vetkez≈ë hasznos met√≥dus a <em>random</em>, amely a random m√≥dulon bel√ºl
                        tal√°lhat√≥ meg egy√©b hasznos f√ºggv√©nyekkel egy√ºtt. Ez l√©trehoz egy megadott mint√°j√∫ random sz√°mokkal
                        felt√∂lt√∂tt t√∂mb√∂t:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">rand_arr = np.random.random([2, 3])
print(rand_arr)
# output:
# [[0.16112766 0.76956209 0.28967126]
# [0.17799395 0.11935788 0.83240867]]</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A <em>linspace</em> l√©trehoz egy meghat√°rozott sz√°m≈± elemb≈ël √°ll√≥ egyenl≈ë
                        eloszl√°s√∫ t√∂mb√∂t, egy megadott intervalumon bel√ºl, az <em>arange</em> is ehhez hasonl√≥, azonban ott
                        l√©peget√©ssel m≈±k√∂dik, teh√°t nem az elemek sz√°m√°t, hanem az elemek k√∂z√∂tti √°lland√≥ k√ºl√∂nbs√©get adjuk meg:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># l√©trehozunk egy 5 elemb≈ël √°ll√≥ egyenl≈ë-eloszl√°s√∫ t√∂mb√∂t 2 √©s 10 k√∂z√∂tt
a = np.linspace(2, 10, 5)
print(a)


# l√©trehozunk egy t√∂mb√∂t 2 √©s 10 k√∂z√∂tt, kettes√©vel l√©pegetve
b = np.arange(2, 10, 2)
print(b)

# output:
# [ 2.  4.  6.  8. 10.]
# [2 4 6 8]
# az arange a fels≈ë hat√°rral kiz√°r√≥, m√≠g a linspace megenged≈ë</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A NumPy eset√©n, az egy-dimenzi√≥s t√∂mb√∂k indexel√©skor √©s slicekor ugyan√∫gy
                        viselkednek, mint a Python list√°k:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
print(a[5])
print(a[1:3])
print(a[::-1])
a[::4] = -1
print(a)

# output:
# 6
# [2 3]
# [9 8 7 6 5 4 3 2 1]
# [-1 2 3 4 -1 6 7 8 -1]</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">A t√∂bb-dimenzi√≥s t√∂mb√∂k indexel√©se nagyban hasonl√≠t az egy-dimenzi√≥s
                        t√∂mb√∂k√©hez. Minden dimenzi√≥nak megvan a maga index √©s slice m≈±velete, √©s ezeket vessz≈ëvel elv√°lasztott
                        tuple-k√©nt hat√°rozzuk meg. A k√∂vetkez≈ë √°bra szeml√©lteti a folyamatot:
                    </p>
                    <figure>
                        <img class="mx-auto"
                            src="../img/fig14.png"
                            alt="√Åbra 14">
                        <figcaption class="text-center pt-3 pb-4 text-md">14. √Åbra: A t√∂bb-dimenzi√≥s indexel√©s NumPy-al
                        </figcaption>
                    </figure>
                    <p class="text-lg font-normal">Abban az esetben, ha az objektumok sz√°ma a tuple-ben kevesebb, mint a dimenzi√≥k
                        sz√°ma, abban az esetben, azt felt√©telezi, hogy a teljes eg√©sz√©t kiv√°lasztottuk a hi√°nyz√≥nak, de ak√°r
                        ellipsziseket is haszn√°lhatunk a teljes kiv√°laszt√°sra:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">a = np.arange(16, dtype='int64')
a = a.reshape([2, 2, 4])
# print(a)
# print(a[0, 1])
print(a[0, :, 2:3])
print(a[0, :, :])
print(a[0, ...])

# output:
# [[2]
#  [6]]
# [[0 1 2 3]
#  [4 5 6 7]]
# [[0 1 2 3]
# [4 5 6 7]]</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Az egyik legjobb dolog a NumPy t√∂mb√∂kkel kapcsolatosan, hogy k√©pes vagy
                        alapvet≈ë √©s nem is annyira alapvet≈ë m≈±veleteket elv√©gezni vel√ºk, olyan m√≥don ahogy azt kor√°bban is
                        megszokhattad, teh√°t mint sima numerikus v√°ltoz√≥kkal. Az egyszer≈± matematikai m≈±veletek, ahogy azt
                        elv√°rn√°nk minden t√∂mbelemen v√©grehajt√°sra ker√ºlnek:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">a = np.arange(1, 7, dtype='int64')
print(a)
a = a.reshape([2, 3])
print(a)
print(a + 2)
print(a * 2)
print(a / 2.0)
# a fenti oszt√°s eset√©ben, implicit m√≥don, amikor float sz√°mmal osztunk, a t√∂mb √°talak√≠t√°sra ker√ºl float64 t√≠pus√∫v√°

# output:
# [1 2 3 4 5 6]
# [[1 2 3]
#  [4 5 6]]
# [[3 4 5]
#  [6 7 8]]
# [[ 2  4  6]
#  [ 8 10 12]]
# [[0.5 1.  1.5]
# [2. 2.5 3. ]]</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A logikai oper√°torok hasonl√≥ logika ment√©n m≈±k√∂dnek, ahogy azt a k√∂vetkez≈ë
                        p√©lda is szeml√©lteti:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(a &#60; 4)
# output:
# [[ True  True  True]
# [False False False]]</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A t√∂mb√∂k emellett hasznos met√≥dusokkal is rendelkeznek, a m≈±veleteken t√∫l,
                        amelyeket a k√∂vetkez≈ë p√©lda is szeml√©ltet:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">a = np.arange(10).reshape([2, 5])

print(a.min(axis=1))
# output: [0 5]

print(a.sum(axis=0))
# output: [ 5  7  9 11 13]

print(a.sum(axis=1))
# output: [10 35]

print(a.mean(axis=1))
# output: [2. 7.]

# sz√≥r√°s
print(a.std(axis=1))
# output: [1.41421356 1.41421356]

# az axis = 0 eset√©n, f√ºgg√∂legesen, a dimenzi√≥k k√∂z√∂tt, √∂sszegzi (pl.) az elemeket 
# az axis = 1 eset√©n, v√≠zszintesen, a dimenzi√≥kon bel√ºl, √∂sszegzi az elemeket</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Tov√°bb√°, nagysz√°m√∫ be√©p√≠tett t√∂mb f√ºggv√©nnyel is rendelkezik a NumPy,
                        megintcsak az al√°bbi p√©lda szeml√©ltet ezek k√∂z√ºl n√©h√°nyat:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">pi = np.pi
a = np.array([pi, pi/2, pi/4, pi/6])
print(np.degrees(a)) # √°talak√≠tja radi√°nb√≥l fokba a megadott t√∂mb elemeit
# output: [180.  90.  45.  30.]

sin_a = np.sin(a) # visszat√©r√≠ti a radi√°nok szinusz √©rt√©k√©t
print(sin_a)
# output: [1.22464680e-16 1.00000000e+00 7.07106781e-01 5.00000000e-01]

print(np.round(sin_a, 7)) # kerek√≠ti 7 tizedespontos√°ggal
# output: [0.        1.        0.7071068 0.5      ]

a = np.arange(8).reshape([2, 4])

print(np.cumsum(a, axis=1))
# halmozott √∂sszeg a m√°sodik tengely ment√©n, teh√°t jelenesetben v√≠zszintesen, dimenzi√≥kon bel√ºl

print(np.cumsum(a))
# a tengelymeghat√°roz√°s n√©lk√ºl a t√∂mb kisimul, teh√°t egy-dimenzi√≥ss√° alakul

# output:
# [[ 0  1  3  6]
#  [ 4  9 15 22]]
# [ 0 1 3 6 10 15 21 28]</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">F√ºggetlen√ºl att√≥l, hogy melyik Python adat-feldolgoz√°si k√∂nyvt√°rat
                        haszn√°lod,
                        legyen az Pandas, Scipy, vagy scikit-learn, esetleg PyBrain, nagy es√©ly van r√°, hogy az alapvet≈ë m√∂g√∂ttes
                        adat-strukt√∫ra a NumPy t√∂mbje lesz.
                    </p>
                    <p class="text-lg font-normal pb-3">Ilyen √©rtelemben, a k√©pess√©g arra, hogy l√©trehozhassunk t√∂mb feldolgoz√°si
                        f√ºggv√©nyeket nagy seg√≠ts√©g√ºnkre lehet a tov√°bbiakban.
                    </p>
                    <p class="text-lg font-normal pb-3">A k√∂vetkez≈ëkben ezzel ismerked√ºnk meg mik√∂zben megpr√≥b√°ljuk megszel√≠diteni
                        a t√∂mb√∂ket, hogy kisz√°molhassunk egy statisztikai mozg√≥√°tlagot. Nagyon egyszer≈±en elmondva a mozg√≥√°tlag
                        egy olyan statisztikai sz√°m√≠t√°s, amely sor√°n az √°ltal elemezz√ºk az adatpontokat, hogy a nagy adatsort
                        kisebb adatsorokra bontjuk √©s azok √°tlagait √°tlagoljuk.
                    </p>
                    <p class="text-lg font-normal pb-3">A k√∂vetkez≈ëkben ezzel ismerked√ºnk meg mik√∂zben megpr√≥b√°ljuk megszel√≠diteni
                        a t√∂mb√∂ket, hogy kisz√°molhassunk egy statisztikai mozg√≥√°tlagot. Nagyon egyszer≈±en elmondva a mozg√≥√°tlag
                        egy olyan statisztikai sz√°m√≠t√°s, amely sor√°n l√©nyeg√©ben √°tlagok sorozat√°t sz√°moljuk egy mozg√≥ "ablakon"
                        (adatsoron) bel√ºl a legutols√≥ n darab √©rt√©kb≈ël, ahol az n egy v√°ltoz√≥ sz√°m.
                    </p>
                    <p class="text-lg font-normal">Egy-dimenzi√≥s t√∂mb eset√©ben n√©h√°ny sor alatt ki lehet sz√°molni a mozg√≥√°tlagot:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">def moving_average(a, n=3):
    ret = np.cumsum(a, dtype=float)
    ret[n:] = ret[n:] - ret[:-n]
    return ret[n - 1:] / n</code><button id="copy"
        class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Teh√°t, a f√ºggv√©ny bevesz egy a t√∂mb√∂t, √©s egy n sz√°mot, amely meghat√°rozza
                        a
                        mozg√≥ ablakunk hossz√°t, jelen esetben alap√©rtelmezetten ez egyenl≈ë 3-al. Els≈ë l√©p√©sben, halmozott √∂sszeget
                        sz√°molunk a NumPy be√©p√≠tett f√ºggv√©ny√©vel. A halmozott √∂sszeg, mint tudjuk, l√©nyeg√©ben a t√∂mb elemein
                        v√©gighaladva, az √∂sszes addigi elem √∂sszege, bele√©rtve az aktu√°list is.
                    </p>
                    <p class="text-lg font-normal">M√°sodik l√©p√©sben, kezdve a halmozott √∂sszeg n-edik index√©t≈ël, kivonjuk az
                        i-n-edik √©rt√©k√©t minden i-b≈ël, ami azt jelenti, hogy az i most minden √©rt√©k √∂sszege az utols√≥ n elemnek,
                        bele√©rtve az n-ediket is, valahogy √≠gy:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="plaintext">[ 0, 1, 2, 3, 4, 5] t√∂mb eset√©n, el≈ësz√∂ris halmozott √∂sszeget sz√°molunk, √≠gy megkapjuk
a [0, 1, 3, 6, 10, 15] t√∂mb√∂t, k√∂vetkez≈ë l√©p√©sben elkezdj√ºk az n-edik indext≈ël, √©s kivonjuk bel≈ële az i-n-edik indexet,
√≠gy a t√∂mb a [0, 1, 3, 6-0, 10-1, 15-3] t√∂mb√∂t,
mivel 3 elemb≈ël √°ll√≥ subseteink vannak, 3-1-t≈ël van √©rtelme √°tlagot sz√°molni, √≠gy a visszat√©r√≠tett √°tlagjaink a
[3 / 3, 6 / 3, 9 / 3, 12 / 3] lesznek.</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Ak√°r pap√≠r mellett √©l≈ëben is megvizsg√°lhatjuk a f√ºggv√©ny√ºk helyes m≈±k√∂d√©s√©t:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(moving_average(np.arange(6)))
# output: [1. 2. 3. 4.]</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                </section>

                <section id="4pandas">
                    <h2 class="text-2xl pt-8 pb-4 font-semibold text-gray-800">Bevezet√©s a Pandas-ba</h2>
                    <p class="text-lg font-normal pb-3">A Pandas az egyik legfontosabb eleme az adat-vizualiz√°ci√≥s
                        eszk√∂zt√°runknak, hiszen ezt a k√∂nyvt√°rat fogjuk haszn√°lni a kor√°bban megszerzett adat√∂sszes√©g√ºnk
                        tiszt√≠t√°s√°ra √©s felfedez√©s√©re, valamint elemz√©s√©re. Alapvet≈ëen, b√°rmilyen adat-vizualiz√°ci√≥t vesz√ºnk a
                        netr≈ël, vagy ak√°r pap√≠r form√°ban, nagy az es√©ly r√°, hogy a megjelen√≠tett adat, kor√°bban valamilyen
                        t√°bl√°zatos form√°ban ker√ºlt t√°rol√°sra, legyen az Excel vagy egyszer≈± CSV √°llom√°ny. A Pandas pont a
                        t√°bl√°zatos form√°ban t√°rolt adatok feldolgoz√°s√°ra ker√ºlt testreszab√°sra, hiszen az alapvet≈ë adatt√≠pusa a
                        DataFrame, amelyet legjobban egy nagyon gyors spreadsheetk√©nt lehet felfogni.</p>
                    <p class="text-lg font-normal pb-3">Alapvet≈ëen, a Pandas-t arra tervezt√©k, hogy heterog√©n adatokkal dolgozzon,
                        amelyek a t√°bl√°zatos form√°ban megjelen√≠tett spreadsheetekben is tal√°lhat√≥k, azonban nagyon j√≥l kitudja
                        haszn√°lni m√©g ekkor is a NumPy gyorsas√°g√°t, amelyet pedig homog√©n numerikus t√∂mb√∂k rendez√©s√©re
                        sz√°nd√©koltak, matematikusok, fizikusok, stb. seg√≠ts√©g√©re.</p>
                    <p class="text-lg font-normal pb-3">Miel≈ëtt nekifogn√°nk, hogy megismerkedj√ºnk a Pandas-al, els≈ëk√©nt annak
                        DataFrame t√≠pus√°val, √©s azzal, hogy hogyan lehet az adatunkat √°thelyezni DataFrame-b≈ël a gyakori
                        adatt√°rol√°si lehet≈ës√©geinkb≈ël, ak√°r f√°jlokb√≥l, ak√°r adatb√°zisokb√≥l, el≈ësz√∂ris megkell √©rten√ºnk azt, hogy
                        mit is √©rt√ºnk a heterog√©n adatsorok, adatok alatt, amelyekre tervezt√©k a Pandas-t.</p>
                    <p class="text-lg font-normal pb-3">Ha egy vizualiz√°ci√≥t n√©z√ºnk, legyen az b√°rmilyen form√°ban, ak√°r egy
                        oszlopdiagram vagy vonaldiagram, amelyet egy cikk vagy valamilyen dashboard illusztr√°l√°s√°ra k√©sz√≠tettek
                        el, nagy es√©ly van r√°, hogy egy val√≥di m√©r√©s eredm√©ny√©t √°br√°zolja √©s mutatja be, p√©ldak√©ppen az egy √©v
                        alatti csapad√©kv√°ltoz√°st, vagy ak√°r etnikai csoportok szerinti szavaz√°si hajland√≥s√°g, stb, a lehet≈ës√©gek
                        l√©nyeg√©ben v√©gtelenek. Nam√°rmost, ezek a m√©r√©sek sz√©les √©rtelemben v√©ve k√©t csoportba oszthat√≥k
                        <em>numerikus</em> √©s <em>kategorikus</em> m√©r√©sek.</p>
                    <p class="text-lg font-normal pb-3">Tov√°bb√°, a numerikus √©rt√©kek megintcsak k√©t kateg√≥ri√°ba oszthatok, vannak
                        <em>intervallum</em> numerikus adatok √©s <em>ar√°nysz√°mok</em>. A kategorikus √©rt√©kek k√©t t√≠pusa pedig a
                        <em>nomin√°lis</em>
                        √©s
                        <em>ordin√°lis</em> m√©r√©sek.</p>
                    <p class="text-lg font-normal">P√©ldak√©ppen, vegy√ºk a k√∂vetkez≈ë esetet, a p√©lda nem, m√°st mint egy tweet, az
                        azt tartalmaz√≥ egy√©b adatmez≈ëkkel:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">{
"text": "#Python and #JavaScript sitting in a tree...",
"id": 2103303030333004303,
"favorited": true,
"filter_level":"medium",
"created_at": "Wed Mar 23 14:07:43 +0000 2015",
"retweet_count":23,
"coordinates":[-97.5, 45.3]
...
}</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">A p√©ld√°t v√©ve, elmondhat√≥, hogy a 'text' √©s 'id' mez≈ëk egyedi azonos√≠t√≥k,
                        az
                        els≈ë ak√°r tartalmazhat kategorikus inform√°ci√≥t is (pl. azon tweetek kateg√≥ri√°ja, amelyek tartalmazz√°k a
                        #python hashtaget), a m√°sodik ak√°r kateg√≥ria l√©trehoz√°s√°ra is haszn√°lhat√≥ (pl. azon felhaszn√°l√≥k
                        kateg√≥ri√°ja, akik retweetelt√©k a tweetet), de ebben az √°llapotukban √©s ilyen form√°ban ezek nem
                        vizualiz√°lhat√≥k. Azt√°n, a 'favorited' mez≈ë a fenti sz√°mokkal √©s stringekkel ellent√©tben boolean √©rt√©k, √≠gy
                        kategorikus inform√°ci√≥, hiszen a tweeteket k√©t csoportba osztja. A kategorikus m√©r√©sen bel√ºl a 'favorited'
                        mez≈ë nomin√°lisnak sz√°m√≠t, hiszen meglehet sz√°molni, de nem lehet sorbarendezni.</p>
                    <p class="text-lg font-normal pb-3">A 'filter_level' ugyancsak kategorikus m√©r√©s, azonban ez m√°r ordin√°lis,
                        hiszen
                        k√©pesek vagyunk egy sorrendet fel√°ll√≠tani. A 'created_at' m√°r numerikus m√©r√©s, azon bel√ºl intervallum, √©s
                        vizualiz√°ci√≥kor p√©ld√°ul ezen sk√°la ment√©n szeretn√©nk rendezni a tweeteket, id≈ërendi sorrendben, ak√°r
                        napokra √©s hetekre lebontva, ezt a folyamatot nagyban megk√∂nny√≠ti a Pandas, s≈ët, a rendez√©st automatikusan
                        v√©gzi el. A 'retweet_count' szint√©n numerikus adat, de ebben az esetben egy ar√°nysz√°m/ar√°ny-sk√°la. Az
                        ar√°nysk√°l√°nak az a nagyon fontos tulajdons√°ga, hogy van egy jelent≈ës√©gteljes z√©r√≥ √©rt√©ke, ebben az esetben
                        ez a retweet hi√°ny√°t jelenti, az el≈ëz≈ë 'created_at' adatunk eset√©n tetsz≈ëleges √©rt√©keket vehet fel, √©s
                        tetsz≈ëleges alap√°llapota/alapvonala, kiindul√°si pontja lehet.</p>
                    <p class="text-lg font-normal pb-3">A 'coordinates' mez≈ë m√°r k√©t numerikus sk√°l√°val rendelkezik, egy
                        hossz√∫s√°gi
                        koordin√°t√°val, √©s egy sz√©less√©givel. Hi√°ba mondhat√≥ el a hossz√∫s√°gir√≥l, hogy √∂nk√©nyesen ker√ºlt
                        kiv√°laszt√°sra, jelenesetben a Greenwich-i d√©lk√∂rt≈ël sz√°molva, a sz√©less√©gi k√∂r pedig az egyenl√≠t≈ët≈ël van,
                        ebben az esetben m√°r szab√°lyszer≈±en, hiszen a F√∂ld p√≥lusai hat√°rozz√°k meg, mindkett≈ë intervallum, hiszen
                        nem sok √©rtelme van fokok eset√©ben ar√°nysz√°mnak tekinteni ≈ëket.</p>
                    <p class="text-lg font-normal pb-3">Teh√°t, a fenti p√©ld√°nk r√°mutat arra, hogyan is lehet elk√©pzelni a
                        heterog√©n
                        adatokat, lefedve a leggyakoribb √©s legelfogadtabb m√©r√©si t√≠pusokat. Ugyanakkor, a NumPy t√∂mb√∂k
                        √°ltal√°noss√°gban v√©ve homog√©n, sz√°madatok kezel√©s√©re lettek kidolgozva, a Pandas pont a fenti p√©ld√°ban
                        szeml√©ltet kategorikus adatokkal, id≈ësorokkal val√≥ munk√°ra √©s egy√©b elemek kezel√©s√©re lett kidolgozva,
                        amelyek a
                        val√≥vil√°got √©s annak heterogenit√°s√°t t≈±kr√∂zik.</p>
                    <p class="text-lg font-normal">Miut√°n, √∂sszes√©g√©ben megbesz√©lt√ºk azt, hogy milyen adatokkal dolgozik a
                        Pandas, megvizsg√°lhatjuk az elemi adatstrukt√∫r√°j√°t a DataFrame-t. A Pandas-al val√≥ munka els≈ë l√©p√©se
                        √°ltal√°ban az, hogy bet√∂lts√ºk az adatainkat egy DataFrame-be. Erre sz√°mos megk√∂zel√≠t√©s van, jelen esetben
                        megoldjuk az eg√©szet √∫gy, hogy beolvassuk a JSON adatainkat a m√°r meglev≈ë <em>nobel_winners.json</em>
                        √°llom√°nyunkb√≥l:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">import pandas as pd

# a f√ºggv√©ny visszat√©r√≠t egy DataFrame-t, elemezve a megadott JSON f√°jlt
# konvenci√≥ szerint a DataFrame v√°ltoz√≥k df-el kezd≈ëdnek
df = pd.read_json('nobel_winners.json')

print(df.head())

# output:
#     category             name nationality     sex  year
# 0    Physics  Albert Einstein       Swiss    male  1921
# 1    Physics       Paul Dirac     British    male  1933
# 2 Chemistry Marie Curie Polish female 1911</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A fenti esetben m√°r haszn√°ltuk is a DataFrame <em>head</em> met√≥dus√°t, amely
                        seg√≠ts√©g√©vel alap√©rtelmezetten az els≈ë 5 sort √≠rja ki. Nam√°rmost, szeretn√©nk a kor√°bbi scrapel√©si munka
                        sor√°n megszerzett, terjedelmes, t√∂bb-soros JSON √°llom√°nyunkat √°thelyezni egy DataFrame-be. Probl√©m√°ba ott
                        √ºtk√∂ztem, mik√∂zben beakartam t√∂lteni, hogy rosszul volt form√°zva a JSON √°llom√°nyom, amikor rosszul van
                        form√°zva a k√∂vetkez≈ë error √ºzenetet √≠rja ki: <em>ValueError: Expected object or value</em> vagy
                        <em>ValueError: Trailing data</em>. A hib√°kat a JSON √°llom√°ny helyesb√≠t√©s√©vel lehet orvosolni, jelen
                        esetben a z√°r√≥jelekkel volt gond.</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')

print(df.head())

df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/minibios.json')

print(df.head())</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">A fenti megjelen√≠t√©sek m√°s t≈±kr√∂zik azt, hogy a DataFrame az eml√≠tett
                        t√°bl√°zatos form√°val dolgozik, teh√°t a mez≈ëk oszlopokk√©nt √©s a mez≈ë √©rt√©kek pedig soronk√©nt m≈±k√∂dnek,
                        kieg√©sz√≠tve egy sorsz√°m oszloppal az elej√©n.</p>
                    <p class="text-lg font-normal">A DataFrame oszlopjai a columns tulajdons√°g szerint vannak indexelve, amely egy
                        Pandas index p√©ld√°ny. A k√∂vetkez≈ëk√©ppen kiv√°laszthatjuk a kor√°bbi DataFrame-jeink oszlopait:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.columns)
# output: Index(['link', 'name', 'year', 'category', 'country', 'born_in', 'text'], dtype='object')</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Alapvet≈ëen, Pandas sorok egyetlen numerikus indexel rendelkeznk (ugyanakkor
                        t√∂bb indexet is k√©pes kezelni, ha az sz√ºks√©ges), amelyek az index tulajdons√°ggal √©rhet≈ëek el:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.index)
# output: RangeIndex(start=0, stop=1163, step=1)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Ebben az esetben egy intervallum t√©r√≠t vissza, abb√≥l az okb√≥l kifoly√≥lag,
                        hogy
                        nagyon hossz√∫ JSON √°llom√°nyunk van. R√∂videbb eset√©ben ak√°r egy <em>Int64Index([0, 1, 2, ...],
                            dtype='int64')</em> t√©r√≠tett volna vissza. Tov√°bb√°, ahogy eg√©sz sz√°mok, a sorindexek ak√°r stringek is
                        lehetn√©nek, <em>DatetimeIndices</em> vagy <em>PeriodIndices</em> id≈ë-alap√∫ adatok eset√©n, stb.</p>
                    <p class="text-lg font-normal">Gyakran ak√°r az is megt√∂rt√©nhet, hogy ahhoz, hogy egyszer≈±s√≠ts√ºk √©s sz≈±k√≠ts√ºk a
                        keres√©st az egyik oszlopot be√°ll√≠tjuk a DataFrame indexek√©nt, a <em>set_index</em> met√≥dus √°ltal:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># haszn√°ljuk a set_index met√≥dust, hogy be√°ll√≠tsuk a DataFrame index√©t a 'name' oszlopra,
df = df.set_index('name')
# majd haszn√°ljuk a loc met√≥dust, hogy kiv√°lasszunk sorokat, amelyek tartalmazz√°k a megadott elemet
print(df.loc['Albert Einstein'])
# v√©g√ºl, haszn√°lva a reset_index met√≥dust vissza√°ll√≠tjuk az eredeti √°llapot√°ba
df = df.reset_index()</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">A DataFrame sorai √©s oszlopai <em>Pandas Series-k√©nt</em> vannak t√°rolva,
                        a
                        NumPy t√∂mbjeinek heterog√©n megfelel≈ëje. Ezek alapjaiban c√≠mk√©zett egy-dimenzi√≥s t√∂mb√∂k, amelyek b√°rmilyen
                        adatt√≠pust k√©pesek t√°rolni, legyen az elemi vagy √∂sszetett.</p>
                    <p class="text-lg font-normal">H√°rom m√≥d van arra, hogy kiv√°lasszunk egy sort egy DataFrame-b≈ël. Az el≈ëbb
                        l√°thattuk a <em>loc</em> met√≥dust, amely a megadott c√≠mke szerint v√°laszt ki elemeket. L√©tezik az
                        <em>iloc</em> met√≥dus, amely poz√≠ci√≥ szerint v√°laszt ki:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># kiv√°lasztja a met√≥dus a m√°sodik sort, amely a head eset√©n lenne a m√°sodik
print(df.iloc[2])</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">V√©g√ºl, van egy <em>ix</em> met√≥dus is, amely √∂tv√∂zi a c√≠mk√©zett el√©r√©st a
                        poz√≠ci√≥ szerinti el√©r√©ssel. Alapvet≈ëen, az ix a c√≠mk√©zett el√©r√©st helyezi fontoss√°gi sorrend szerinti els≈ë
                        helyre, de m√°sodik megold√°sk√©nt mindig az eg√©sz sz√°m√∫ poz√≠ci√≥ szerinti el√©r√©sre t√©r vissza, amennyiben
                        eg√©sz sz√°mmal haszn√°ljuk a met√≥dust, illet≈ëleg a tengely, jelen esetben a 'names' oszlop, nem egy eg√©sz
                        sz√°m. Azonban, a k√©t√©rtelm≈±s√©ge miatt √∫jabb Pandas csomagokban m√°r nem √©l a met√≥dus, √©s kiz√°r√≥lag a loc √©s
                        iloc met√≥dusokkal lehet sorokat el√©rni.</p>
                    <p class="text-lg font-normal">√Ått√©rve az oszlopokra, k√©pesek vagyunk egy teljes oszlopot kiv√°lasztani a
                        DataFrame-b√≥l a megszokott pontos jel√∂l√©st haszn√°lva, vagy ak√°r haszn√°lva a hagyom√°nyos t√∂mb-szer≈±
                        jel√∂l√©st is:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">name_col = df.name # == df['name']
print(type(name_col))
print(name_col)

''' &#60;class 'pandas.core.series.Series'>
0                            Howard Florey
1              Sir Frank Macfarlane Burnet
2                   William Lawrence Bragg
3                         C√©sar Milstein *
4                        John Carew Eccles
                       ...
1158                         Albert Claude
1159    International Atomic Energy Agency
1160                          Peter Handke
1161                     Corneille Heymans
1162                      Elfriede Jelinek
Name: name, Length: 1163, dtype: object '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Tov√°bb√°, sz√°mos megk√∂zel√≠t√©s van arra is, hogy csoportokat (val√≥j√°ban
                        sorok
                        csoportjait) v√°lasszunk ki a DataFrame-√ºnkb≈ël, visszat√©r√≠tve egy √∫j, m√°r sz≈±rt DataFrame-t. Gyakran ki
                        szeretn√©nk v√°lasztani azokat a sorokat, amely tartalmaznak egy bizonyos oszlop √©rt√©ket, p√©ldaul
                        kiszeretn√©nk v√°lasztani a fizikai Nobel-d√≠jt nyert szem√©lyeket.</p>
                    <p class="text-lg font-normal">Az egyik megk√∂zel√≠t√©s lenne a DataFrame <em>groupby</em> met√≥dusa, amely
                        kiv√°laszt egy oszlopot, majd haszn√°lhatn√°nk ezen a DataFrame-n a <em>get_group</em> met√≥dust, amely
                        kiv√°lasztan√° az √©rdekelt csoportot:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># kiv√°lasztjuk a kateg√≥ria oszlopot
df = df.groupby('category')
print(df.groups.keys())
# output: dict_keys(['', 'Chemistry', 'Economics', 'Literature', 'Peace', 'Physics', 'Physiology or Medicine'])
# az√©rt van egy √ºres kateg√≥ria is, mert el√≠rt√°k a Wikip√©dia oldalon, √©s nem egys√©ges a jel√∂l√©s

# lek√©rj√ºk, majd ki√≠rjuk a fizikai Nobel-d√≠j gy≈ëzteseket
phy_group = df.get_group('Physics')
print(phy_group.head())</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A m√°sodik megk√∂zel√≠t√©st egy √∫n. boolean mask-ot haszn√°l ahhoz, hogy l√©trehozzon
                        egy √∫j DataFrame-t. K√©pesek vagyunk egy boolean oper√°tort haszn√°lni az √∂sszes oszlopon egy DataFrame-ben,
                        pontosan olyan m√≥don ahogyan azt egy NumPy t√∂mb eset√©n is tehetn√©nk:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.category == 'Physics')

''' output: 
0       False
1       False
2        True
3       False
4       False
        ...
1158    False
1159    False
1160    False
1161    False
1162 False '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A haszn√°lt boolean mask-ot majd haszn√°lhatjuk az eredeti DataFrame-n, hogy
                        kiv√°lasszuk a sorainak egy alcsoportj√°t:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df[df.category == 'Physics'])

''' output:
                                                   link  ...                                               text
2     http://en.wikipedia.org/wiki/William_Lawrence_...  ...             William Lawrence Bragg , Physics, 1915
6            http://en.wikipedia.org/wiki/Brian_Schmidt  ...  Brian Schmidt ,  born in the United States , P...
17    http://en.wikipedia.org/wiki/Erwin_Schr%C3%B6d...  ...                  Erwin Schr√∂dinger , Physics, 1933
18     http://en.wikipedia.org/wiki/Victor_Francis_Hess  ...                Victor Francis Hess , Physics, 1936
27          http://en.wikipedia.org/wiki/Wolfgang_Pauli  ...                     Wolfgang Pauli , Physics, 1945
...                                                 ...  ...                                                ...
1131         http://en.wikipedia.org/wiki/Brian_Schmidt  ...  Brian Schmidt ,  born in the United States , P...
1147      http://en.wikipedia.org/wiki/Donna_Strickland  ...                   Donna Strickland , Physics, 2018
1149  http://en.wikipedia.org/wiki/William_Lawrence_...  ...             William Lawrence Bragg , Physics, 1915
1151    http://en.wikipedia.org/wiki/Arthur_B._McDonald  ...                 Arthur B. McDonald , Physics, 2015
1156 http://en.wikipedia.org/wiki/Fran%C3%A7ois_Eng... ... Fran√ßois Englert , Physics, 2013 '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Sz√°mos tov√°bbi p√©ld√°t fogunk m√©g l√°tni arra, hogy hogyan tudunk adatokat
                        kiv√°lasztani, ugyanakkor el≈ësz√∂r azzal fogunk m√©g jobban megismerkedni, hogy hogyan tudunk l√©trehozni
                        DataFrame-eket l√©tez≈ë adatokb√≥l √©s hogyan tudjuk lementeni a DataFrame kezel√©sek eredm√©nyeit.</p>
                    <p class="text-lg font-normal pb-3">A legk√∂nnyebb m√≥d arra, hogy l√©trehozzunk egy DataFrame-t az, hogy Python
                        dict-et haszn√°lunk. Ugyanakkor, √©rtelemszer≈±en ez lesz az a m√≥d is, amit a legkev√©sb√© fogunk haszn√°lni,
                        hiszen az esetek t√∂bbs√©g√©ben vagy f√°jlokb√≥l vagy adatb√°zisb√≥l fog sz√°rmazni az adatunk.</p>
                    <p class="text-lg font-normal">Alap√©rtelmezetten, meghat√°rozzuk az oszlopokat k√ºl√∂n, a k√∂vetkez≈ë p√©lda ezt
                        szeml√©lteti, amelyben l√©trehozunk egy 3 soros t√°bl√°zatot 'name' √©s 'category' oszlopokkal:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = pd.DataFrame({
    'name': ['Albert Einstein', 'Marie Curie', 'William Faulkner'],
    'category': ['Physics', 'Chemistry', 'Literature']
})

print(df.head())
''' output:
               name    category
0   Albert Einstein     Physics
1       Marie Curie   Chemistry
2 William Faulkner Literature '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Tov√°bb√°, a fenti p√©ld√°hoz nagyban hasonl√≥an k√©pesek vagyunk az
                        <em>from_dict</em> met√≥dust haszn√°lni, hogy rekord-alap√∫ (record based) l√©trehoz√°shoz, amikor is egy t√∂mb
                        dict-et adunk meg, amelyben mindenik egy √∫jabb rekord √©s egy √∫jabb sort jel√∂l a DataFrame-√ºnkben. A
                        from_dict rendelkezik egy <em>orient</em>
                        argumentummal is, amely lehet≈ëv√© teszi, hogy meghat√°rozzuk a rekord t√≠pus√∫ adatunkat √©s annak form√°j√°t, de
                        a Pandas ez okosan, mag√°t√≥l is k√©pes kik√∂vetkeztetni az adatb√≥l:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = pd.DataFrame.from_dict([
    {'name': 'Albert Einstein', 'category': 'Physics'},
    {'name': 'Marie Curie', 'category': 'Chemistry'},
    {'name': 'William Faulkner', 'category': 'Literature'}
])

print(df.head())
''' output:
               name    category
0   Albert Einstein     Physics
1       Marie Curie   Chemistry
2 William Faulkner Literature '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Mivel eml√≠tett√ºk, hogy nem igaz√°n fogjuk valaha is haszn√°lni a fenti
                        megold√°sokat, t√©rj√ºnk is r√° a l√©nyegre, a f√°jlb√≥l/adatb√°zisb√≥l t√∂rt√©n≈ë beolvas√°sra. A Pandas rengeteg
                        <em>read_[form√°tum]/to_[form√°tum]</em> met√≥dussal rendelkezik, amelyek lefedik a legt≈ëbb elk√©pzelhet≈ë
                        adat-beolvas√°si esetet, eg√©szen CSV f√°jlokt√≥l kezdve a bin√°ris HDF5 form√°tumon kereszt√ºl, az SQL
                        adatb√°zisokig. A mi munk√°nkhoz elengedhetetlen eseteket a tov√°bbiakban meg is vizsg√°ljuk.</p>
                    <p class="text-lg font-normal pb-3">Fontos azt is megjegyezni, hogy alap√©rtelmezetten a Pandas megpr√≥b√°lja
                        n√©mik√©pp finoman √°talak√≠tani a beolvasott adatokat. A legt√∂bb beolvas√°si met√≥dus opci√≥kkal rendelkezik,
                        mint p√©ld√°ul a <em>convert_axes</em>, amely megpr√≥b√°lja √°talak√≠tani a tengelyeket megfelel≈ë dtype-okk√°,
                        <em>dtype</em>, illetve a <em>convert_dates</em> is mind Igazra van √°ll√≠tva.</p>
                    <p class="text-lg font-normal pb-3">El≈ësz√∂ris, figyelj√ºk meg azokat az eseteket, amikor f√°jlalap√∫ beolvas√°sr√≥l
                        van sz√≥.</p>
                    <p class="text-lg font-normal">Kor√°bban m√°r l√°thattuk azt, hogyan k√©pes a Pandas JSON √°llom√°nyb√≥l l√©trehozni
                        DataFrame-eket:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code
                            class="python">df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')</code><button id="copy"
                            class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Ugyanakkor, a JSON √°llom√°ny is sz√°mos form√°t felvehet, meghat√°rozva egy
                        opcion√°lis orient argumentummal, az orient a k√∂vetkez≈ë √©rt√©kek valamelyik√©t veheti fel: [split, records,
                        index, columns, values]. Mint mondtuk k√©pes a Pandas √∂nmag√°t√≥l is kik√∂vetkeztetni a megfelel≈ë orient-et,
                        de alap√©rtelmezetten az oszlopos form√°t haszn√°lja. A mi eset√ºnkben a JSON √°llom√°nyunkban tal√°lhat√≥
                        rekord-alap√∫t fogjuk haszn√°lni, hiszen a web-alap√∫ adat-vizualiz√°ci√≥hoz, f≈ëk√©pp a D3-hoz, ez a
                        legmegfelel≈ëbb √©s leggyakoribb megk√∂zel√≠t√©s a t√°bl√°zatos adat √°tad√°s√°hoz.</p>
                    <p class="text-lg font-normal">Sz√°mos m√≥d van arra is, hogy DataFrame-eket JSON-okk√° alak√≠tsunk √°t, ami a
                        form√°tumot illeti (orient√°ci√≥t), ahhoz, hogy a fent eml√≠tett rekord-alap√∫ JSON √°llom√°nyt kapjuk meg a
                        DataFrame-b≈ël a k√∂vetkez≈ët kell √≠rnunk:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')

# elv√©gezz√ºk a sz√ºks√©ges m≈±veletek a df-en ...

json = df.to_json('./nobel_prize/nobel_winners/nobel_winners/nwinners_cleaned.json', orient='records')</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Rendelkez√©s√ºnkre √°llnak a <em>date_format</em>, <em>double_precision</em>,
                        <em>default_handler</em> param√©terek is, ha az objektum nem alak√≠that√≥ √°t JSON-n√° a Pandas parser-√©vel.
                    </p>
                    <p class="text-lg font-normal">A m√°sodik gyakori t√≠pus nem m√°s, mint a CSV f√°jlok. A Pandas CSV f√°jl-kezel√©se
                        annyira kifinomult, hogy szinte a lehet≈ë legt√∂bb elk√©pzelhet≈ë adattal k√©pes elb√°nni ebben a form√°tumban. A
                        konvencion√°lis CSV f√°jlok, a nagy t√∂bbs√©g ilyen, b√°rmif√©le param√©ter n√©lk√ºl k√©pesek bet√∂lteni:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code
                            class="python">df = pd.read_csv('nobel_winners.csv')</code><button id="copy"
                            class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Ugyanakkor, sz√°mos CSV forma van, ami nem vessz≈ëvel van elv√°lasztva, vagy
                        saj√°tos, a szok√°sost√≥l elt√©r≈ë id√©z≈ëjelez√©st haszn√°l olyan stringek eset√©n, amelyek sz√≥k√∂zt vagy speci√°lis
                        karaktereket tartalmaznak. Ilyen esetekben k√©pesek vagyunk b√°rmilyen egy√©ni elemet meghat√°rozni az
                        olvas√°si lek√©rdez√©s√ºnkben, a p√©ld√°nkban haszn√°lva a Python hasznos <em>StringIO</em> m√≥dul√°t, hogy
                        ut√°nozzuk a f√°jlb√≥l val√≥ beolvas√°st:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">from io import StringIO

data = " `Albert Einstein`| Physics \n`Marie Curie`| Chemistry"

# meghat√°rozzuk a szok√°sost√≥l elt√©r≈ë jel√∂l√©seket, mint a mez≈ë elv√°laszt√≥ |-t, a kateg√≥ri√°k neveit, 
# a kezdeti space kihagy√°s√°t, √©s azt a jel√∂l√©si m√≥dot, ahogy a sz√≥k√∂zt tartalmaz√≥ stringek vannak jel√∂lve
df = pd.read_csv(StringIO(data), sep='|', names=['name', 'category'], skipinitialspace=True, quotechar="`")

print(df.head())
''' output:
              name   category
0  Albert Einstein   Physics
1 Marie Curie Chemistry '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">K√©pesek vagyunk a JSON-hoz hasonl√≥an DataFrame-t CSV f√°jll√° is alak√≠tani a
                        k√∂vetkez≈ëk√©ppen:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code
                            class="python">csv = df.to_csv('data.csv', encoding='utf-8')</code><button id="copy"
                            class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">√Ått√©rve az Excel f√°jlokra, a Pandas a Python <em>xlrd</em> m√≥dulj√°t haszn√°lja,
                        hogy olvasson egyar√°nt .xls, √©s .xls f√°jlokb√≥l. Az Excel dokumentumoknak ak√°r t√∂bb elnevezett munkalapja
                        is lehet, amelyek mindegyik DataFrame-√© alak√≠that√≥. K√©t m√≥d van arra, hogy egy munkalapot beolvassunk
                        DataFrame-√©. Az els≈ë megk√∂zel√≠t√©s szerint l√©trehozunk majd elemz√ºnk egy ExcelFile objektumot:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">dfs = {}
xls = pd.ExcelFile('nobel_winners.xlsx') # bet√∂lti az Excel f√°jlt
# fogja a munkalapot n√©v szerint, √©s lementi egy dict-be
dfs['WSheet1'] = xls.parse('WinnersSheet1', na_values = ['NA'])
# ugyan√∫gy, azonban ebben az esetben meghat√°rozzuk el≈ësz√∂ris az oszlopot, poz√≠ci√≥ szerint, hogy haszn√°ljuk, mint a DataFrame sorc√≠mk√©i
# az na_values eset√©ben meghat√°rozzuk azon stringeket, amelyeket NaN-k√©nt kell √©rtelmezzen
# v√©g√ºl a skiprows eset√©ben a sorok sz√°m√°t hat√°rozzuk meg, amelyeket kikell hagyjon feldolgoz√°s el≈ëtt, pl. metaadat lenne ezekben
dfs['WSheet2'] = xls.parse('WinnersSheet2', index_col=0, na_values=['-'], skiprows=3)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Alternat√≠van, k√©pesek vagyunk a <em>read_excel</em> met√≥dust is haszn√°lni,
                        amely egy k√©nyelmesebb megold√°s t√∂bb munkalap beolvas√°s√°ra:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># ebben az esetben a m√°sodik munkalap rosszul form√°zotts√°ga miatt nem megfelel≈ëen olvassa be
data = pd.read_excel('nobel_winners.xlsx', ['WinnersSheet1', 'WinnersSheet2'], index_col=None, na_values = ['NA'])</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Az egyetlen ok ami miatt nem lenne haszn√°lhat√≥ a read_excel met√≥dus az az
                        amikor k√ºl√∂nb√∂z≈ë argumentumokkal szeretn√©nk beolvasni mindenik Excel munkalapot, ahogy azt az els≈ë
                        p√©ld√°ban is l√°thattunk, illet≈ëleg, amely n√©lk√ºl a m√°sodik p√©ld√°ban nem megfelel≈ëen fogja a rosszul
                        form√°zotts√°ga miatt a m√°sodikat helyesen beolvasni.
                    </p>
                    <p class="text-lg font-normal">A read_excel met√≥dus eset√©ben nagyon sok param√©ter √°ll rendelkez√©s√ºnkre,
                        p√©ld√°ul, ha csak az Excel f√°jl nev√©t adjuk meg, abban az esetben csak az els≈ë munkalapot olvassa be, ha
                        None-ra, abban az esetben az √∂sszeset:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">data = pd.read_excel('nobel_winners.xlsx')

data = pd.read_excel('nobel_winners.xlsx', None) # == sheetname=None</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A <em>usecols</em> param√©ter pedig lehet≈ës√©get ny√∫jt arra, hogy kiv√°lasszuk
                        azokat az oszlopokat, amelyeket szeretn√©nk √©rtelmezni √©s beolvasni. A usecols-t t√∂bb form√°tumban is
                        megadhatjuk, a legegyszer≈±bb, ha Excel st√≠lusban adjuk meg ahogy azt a p√©lda is mutatja, de ak√°r egy
                        list√°nyi eg√©sz sz√°mot is megadhatunk, jel√∂lve azokat az oszlopokat, amelyeket beolvasn√°nk:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">data = pd.read_excel('nobel_winners.xlsx', 'WinnersSheet1', index_col=0, usecols='A:C')</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Most az √©rdekesebb r√©szt k√©pesek vagyunk DataFrame-ket is, az el≈ëz≈ë p√©ld√°khoz
                        hasonl√≥an, Excel f√°jlok munkalapjaik√©nt lementeni a <em>to_excel</em> met√≥dussal, megadva az Excel
                        f√°jlnev√©t √©s a munkalapnev√©t:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')

# lementi a DataFrame √©rt√©keit a nobel_winners Excel f√°jlba, l√©trehozva egy √∫j munkalapot WinnersSheet3 n√©ven
# fontos megjegyezni azt, hogy teljesen √∫j Excel f√°jlt hoz l√©tre, t√∂r√∂lve a m√°r l√©tez≈ë munkalapokat
excel = df.to_excel('nobel_winners.xlsx', sheet_name='WinnersSheet3')</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Illet≈ëleg, megt√∂rt√©nhet az is, hogy t√∂bb DataFrame-t szeretn√©nk ki√≠rni egy
                        megosztott Excel f√°jlba, azt valahogy √≠gy tenn√©nk:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df1 = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')
df2 = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/minibios.json')

# ebben az esetben mindk√©t DataFrame-t ugyanabba az Excel f√°jlba fogja √≠rni
with pd.ExcelWriter('nobel_winners.xlsx') as writer:
    df1.to_excel(writer, sheet_name='WinnersSheet')
    df2.to_excel(writer, sheet_name='WinnersBios')</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">√Ått√©rve, f√°jlalap√∫ adatt√°rol√°sr√≥l, adatb√°zis alap√∫ra, a Pandas, ha
                        lehets√©ges,
                        a Python SQLAlchemy m√≥dulj√°t haszn√°lja az adatb√°zis absztrakci√≥hoz. Amennyiben nem √°ll rendelkez√©sre,
                        fallback-k√©nt az sqlite-ra √©p√ºlve a Python szabv√°ny k√∂nyvt√°rat haszn√°lja. Amennyiben, az SQLAlchemy-t
                        haszn√°lod abban az esetben azt is import√°lnod kell.
                    </p>
                    <p class="text-lg font-normal">A legk√∂nnyebb megold√°s arra, hogy egy adatb√°zis t√°bl√°t, vagy SQL lek√©rdez√©s
                        eredm√©ny√©t DataFrame-be olvassuk az <em>read_sql</em> met√≥dus:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># emellett sz√ºks√©g volt a pymysql m√≥dul telep√≠t√©s√©re is pip-el
import sqlalchemy

# el≈ësz√∂ris, l√©trehozzuk a t√°rol√≥motrot, megadva az adatb√°zis el√©r√©s√©t, illet≈ëleg annak nev√©t
engine = sqlalchemy.create_engine('mysql+pymysql://root@localhost/nobel_prize')

# megadjuk els≈ë argumentumk√©nt a beolvasand√≥ SQL t√°bla nev√©t, majd a t√°rol√≥motrot
df = pd.read_sql('nobel_winners', engine)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">DataFrame-ket SQL adatb√°zisba √≠rni is legal√°bb ennyire egyszer≈±, felhaszn√°lva
                        az el≈ëbb l√©trehozott t√°rol√≥motrunkat:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># beolvassuk a JSON √°llom√°nyt, amelyet kiszeretn√©nk √≠rni
df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')
# ki√≠rjuk az adatb√°zisba, az els≈ë argumentumban meghat√°rozva az SQL t√°bla nev√©t, 
# megadva a t√°rol√≥motrot, illet≈ëleg 500-as chunkokban, sorokban, fogja ki√≠rni
df.to_sql('nobel_winners', engine, chunksize=500)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Fontos megeml√≠teni azt, hogy a Pandas megpr√≥b√°lja finoman kik√∂vetkeztetni az
                        adatunkb√≥l, hogy milyen SQL adatt√≠pus felelnek meg neki, ha sz√ºks√©ges ak√°r ezt magunk is megadhatjuk a
                        k√∂vetkez≈ëk√©ppen:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">from sqlalchemy.types import String

df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')
# mivel a VARCHAR t√≠pust haszn√°lja, ez√©rt megkell adni a hosszt is
df.to_sql('nobel_winners', engine, dtype={'year': String(4)})</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">V√©g√ºl, az adat-vizualiz√°ci√≥s munka sor√°n sokat lehetne mes√©lni a
                        dokumentum-alap√∫ NoSQL adatb√°zisok √°ltal ny√∫jtott k√©nyelemr≈ël, ilyen p√©ld√°ul a m√°r kor√°bban eml√≠tett
                        MongoDB. A MongoDB-vel
                        kicsit m√©g jobb a helyzet, hiszen a JSON bin√°ris form√°j√°t haszn√°lja adatt√°rol√≥k√©nt, n√©vszerint a BSON-t.
                        Mivel a JSON ami adat-ragaszt√≥nk, hiszen √∂sszekapcsolja a webes vizualiz√°ci√≥s dolgainkat a backend
                        szerverrel, el√©g j√≥ d√∂nt√©snek t≈±nik az, ha Mongo-n t√°roljuk az adatsorainkat. V√©g√ºl, az sem elhagyhat√≥,
                        hogy el√©g k√∂nnyen kezelhet≈ë egy√ºtt a Pandas-al.
                    </p>
                    <p class="text-lg font-normal">Ahogy azt kor√°bban is l√°thattuk, nagyon egyszer≈±en k√©pesek a Pandas
                        DataFrame-jei JSON form√°tumba alakulni, vagy JSON form√°tumb√≥l beolvas√≥dni, teh√°t egy Mongo dokumentum
                        collection nagyon egyszer≈±en √°talak√≠that√≥ DataFrame-√©:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">from pymongo import MongoClient

# l√©trehozunk egy Mongo klienst, az alap√©rtelmezetten host-al √©s port-al
client = MongoClient()

# lek√©rj√ºk a nobel_prize adatb√°zist
db = client.nobel_prize
# megkeresi az √∂sszes dokumentumot a winners collection-√∂n bel√ºl
cursor = db.winners.find()
# beolvassa az √∂sszes dokumentumot a winners collection-√∂n bel√ºl listak√©nt, hogy l√©trehozza a DataFrame-t
df = pd.DataFrame(list(cursor))</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Azt√°n legal√°bb ennyire egyszer≈± DataFrame-ket MongoDB adatb√°zisba √≠rni, amelyet
                        a k√∂vetkez≈ë k√≥dr√©szlet szeml√©ltet:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># alap√©rtelmezett be√°ll√≠t√°sokkal, csup√°n az adatb√°zisn√©v tetsz≈ëleges
def get_mongo_database(db_name, host='localhost', port=27017, username=None, password=None):
    """ El√©rj√ºk a db_name-mel hivatkozott adatb√°zist MongoDB-r≈ël, hiteles√≠t≈ë adatokkal vagy azok n√©lk√ºl """

    if username and password:
        mongo_uri = 'mongodb://{}:{}@{}/{}'.format(username, password, host, db_name)
        # URI = uniform resource identifier
        conn = MongoClient(mongo_uri)
    else:
        conn = MongoClient(host, port)

    return conn[db_name] # itt m√°r a m√°sodik f√©le jel√∂l√©st haszn√°ljuk az adatb√°zis el√©r√©s√©hez

# felhaszn√°lva a kor√°bban l√©trehozott f√ºggv√©ny√ºnket el√©rj√ºk az adatb√°zist

db = get_mongo_database('nobel_prize')

df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')
records = df.to_dict(orient='records')
db['nwinners_full'].insert_many(records)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A k√∂vetkez≈ëkben √≠rjunk n√©h√°ny hasznos kicsi f√ºggv√©nyt, amely megk√∂nny√≠ti, hogy
                        DataFrame-t √≠rjunk √©s olvassunk egy MongoDB adatb√°zisba/adatb√°zisb√≥l:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">def mongo_to_dataframe(db_name, collection, query={}, host='localhost', port=27017, username=None, password=None, no_id=True):
    """ L√©trehoz egy DataFrame-t egy MongoDB collection-b√≥l """

    db = get_mongo_database(db_name, host, port, username, password)

    # megkeresi a collection-b√≥l a lek√©rdez√©s szerinti elemeket
    cursor = db[collection].find(query)

    df = pd.DataFrame(list(cursor))

    # amennyiben azt szeretn√©nk, hogy t√∂r√∂lje ki a MongoDB √°ltal hozz√°adott id-t
    if no_id:
        del df['_id']

    return df

def dataframe_to_mongo(df, db_name, collection, host='localhost', port=27017, username=None, password=None):
    """ Lement egy DataFrame-t egy MongoDB collection-be """

    db = get_mongo_database(db_name, host, port, username, password)

    records = df.to_dict(orient='records')

    db[collection].insert_many(records)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Egy k√∂vetkez≈ë m√≥d arra, hogy DataFrame-ket hozzunk l√©tre az az, hogy
                        fel√©p√≠tj√ºk ≈ëket <em>Series</em>-ek egy kollekci√≥j√°b√≥l. A k√∂vetkez≈ëkben a Series-t fogjuk k√∂nny≈±
                        r√©szleteiben
                        megismerni.
                    </p>
                    <p class="text-lg font-normal pb-3">A Pandas Series-ei m√∂g√∂tti kulcsgondolat az indexei. Ezek az indexek
                        c√≠mk√©kk√©nt
                        funkcion√°lnak azoknak a heterog√©n adatoknak, amelyek az adatok soraiban tal√°lhat√≥k. Amikor a Pandas t√∂bb,
                        mint egy adat objektumon dolgozik, akkor ezek az indexek vannak felhaszn√°lva, hogy helyreigaz√≠ts√°k a
                        mez≈ëket.
                    </p>
                    <p class="text-lg font-normal">Series-t h√°romf√©lek√©ppen tudunk l√©trehozni. El≈ësz√∂r, k√©pesek vagyunk
                        Python list√°b√≥l vagy NumPy t√∂mbb√∂l l√©trehozni:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">import numpy as np

s = pd.Series(np.arange(1, 5)) # == pd.Series([1, 2, 3, 4])
print(s)

''' output:
0    1  # index, value
1    2
2    3
3    4
dtype: int32 '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Megjegyezend≈ë dolog, hogy az eg√©sz √©rt√©k≈± indexek automatikusan ker√ºlnek
                        l√©trehoz√°sra a Series-√ºnkh√∂z. Ha egy sornyi adatot adn√°nk hozz√° egy DataFrame-hez √©s mi szeretn√©nk
                        meghat√°rozni azok indexeit, abban az esetben megtehetj√ºk azt az √°ltal, hogy beadunk egy list√°nyi eg√©sz
                        sz√°mot vagy valamilyen c√≠mk√©t a k√∂vetkez≈ëk√©ppen:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">s = pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])
print(s)

''' output:
a    1
b    2
c    3
d    4
dtype: int64 '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A fenti esetben fontos megjegyezni azt is, hogy az index t√∂mb hossza, megkell
                        egyezzen az adatokat tartalmaz√≥ t√∂mb hossz√°val. A fenti esetet leegyszer≈±s√≠tve haszn√°lhatjuk a Series-ek
                        l√©trehoz√°s√°ra a Python dict-ekkel t√∂rt√©n≈ë megold√°st is a k√∂vetkez≈ëk√©ppen, amikor egyszerre tudjuk az
                        indexet, illet≈ëleg az adatsort is meghat√°rozni:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">s = pd.Series({'a': 1, 'b': 2, 'c':3, 'd':4 })
print(s)

''' output:
a    1
b    2
c    3
d    4
dtype: int64 '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Abban az esetben, ha a dict-es megk√∂zel√≠t√©s eset√©n egy indexeket tartalmaz√≥
                        t√∂mb√∂t is beadunk a met√≥dusba, a Pandas nagyon √©rthet≈ë m√≥don megpr√≥b√°lja p√°ros√≠tani az indexeket az
                        adatsorhoz, minden olyan index esetet, amelyet nem tud p√°ros√≠tani, az adotthoz indexhez NaN-t rendel, ha
                        egy adott √©rt√©khez az adatsorban nem tartozik index az index t√∂mbb√∂l elveti:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">s = pd.Series({'a': 1, 'b': 2, 'd': 4}, index=['a', 'b', 'c'])
print(s)

''' output:
a    1.0
b    2.0
c    NaN
dtype: float64 '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">V√©g√ºl, k√©pesek vagyunk egyetlen skal√°ris (egyszer≈± numerikus √©rt√©k) √©rt√©ket
                        √°tadni, mint adat a Series-nek, adva, hogy az indexeket meghat√°rozzuk, ebben az esetben az √∂sszes
                        meghat√°rozott indexhez az adott skal√°ris √©rt√©ket rendeli hozz√°:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">s = pd.Series(9, index=[1, 2, 3])
print(s)

''' output:
1    9
2    9
3    9
dtype: int64 '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A Series-ek √∫gy m≈±k√∂dnek, mint a NumPy t√∂mb√∂k (ndarray), ami azt eredm√©nyezi,
                        hogy a legt√∂bb NumPy f√ºggv√©nnyel haszn√°lhat√≥k:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">import numpy as np

s = pd.Series(np.arange(1, 5), index=['a', 'b', 'c', 'd'])
s = np.sqrt(s)
print(s)

''' output:
a    1.000000
b    1.414214
c    1.732051
d    2.000000
dtype: float64 '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">K√∂vetkez≈ë √©rdekess√©g, hogy a slicing oper√°torok is ugyan√∫gy m≈±k√∂dnek,
                        mintha csak NumPy t√∂mb√∂ket, vagy Python list√°kat haszn√°ln√°nk:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(s[1:3])

''' output:
b    1.414214
c    1.732051
dtype: float64 '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A Series legnagyobb el≈ënye a NumPy t√∂mb√∂kkel szemben, ahogy az a bevezet≈ëbe is
                        eml√≠tve volt, hogy t√∂bbf√©le adatt√≠pust is nagyszer≈±en kezel:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(pd.Series([6, 3.2, 'foo']) + pd.Series([3, 0.8, 'bar']))

''' output:
0         9
1         4
2    foobar
dtype: object '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Mivel a DataFrame-k √©pit≈ëkock√°inak az iment megismert Series-ek sz√°m√≠tanak, nem
                        t√∫l bonyol√∫lt feladat √∂sszes√≠teni ezeket l√©trehozva DataFrame-ket, felhaszn√°lva a Pandas <em>concat</em>
                        met√≥dus√°t:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># a name argumentummal egyszer≈±en meghat√°rozok a Series nev√©t, amely k√©s≈ëbb az oszlopn√©v lesz
names = pd.Series(['Albert Einstein', 'Marie Curie'], name='name')
categories = pd.Series(['Physics', 'Chemistry'], name='category')

# az axis=1 √°ltal "v√≠zszintesre" √°ll√≠tjuk az √∂sszes√≠t√©st, azaz azt hat√°rozzuk meg, hogy a Series-ek oszlopok
df = pd.concat([names, categories], axis=1)
print(df.head())

''' output:
              name   category
0  Albert Einstein    Physics
1 Marie Curie Chemistry '''</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">V√©g√ºl, pedig az utols√≥ bevezet≈ë dologr√≥l kell besz√©ln√ºnk, ami nem m√°s,
                        mint a
                        Pandas <em>Panel</em>. A Panel class l√©nyeg√©ben nem m√°s, mint egy kont√©ner t√∂bb DataFrame-hez. Ahogyan a
                        DataFrame l√©nyeg√©ben Series-ekb≈ël √©p√ºl fel, √∫gy a Panel DataFramek-ekb≈ël √©p√ºl fel. A Panel egy √∫jabb
                        dimenzi√≥t ad hozz√° a DataFrame-hez, ez √°ltal mivel a harmadik szintet k√©pviseli, h√°rom-dimenzi√≥s
                        kont√©nerr√© v√°lik. Teh√°t, √∂sszes√©g√©ben az indexeken √©s oszlopokon t√∫l, amelyekkel a DataFrame rendelkezik,
                        biztos√≠t egy √∫jabb tengelyt, amely meghat√°rozza melyik DataFrame-n√©l vagyunk jelenleg. Tov√°bb√°, √©rdemes
                        volt megismerni a koncepci√≥t, de a Pandas leg√∫jabb v√°ltozataiban ez a class m√°r nem √©rhet≈ë el.
                    </p>
                </section>

                <section id="4cleaning">
                    <h2 class="text-2xl pt-8 pb-4 font-semibold text-gray-800">Tiszt√≠tsuk meg az adatunkat Pandas-al</h2>
                    <p class="text-lg font-normal pb-3">A legt√∂bb kezd≈ë adat-megjelen√≠t≈ë eleinte al√∫lbecs√ºli azt az id≈ët, amit
                        adataink helyrerak√°s√°val, annak alak√≠t√°s√°val fog elt√∂lteni, csak az√©rt, hogy az adat bemutathat√≥ lehesse.
                        A val√≥ √©letben nagyon ritka a t√∂k√©letesen bejegyzett adat, gyakran fogunk hi√°nyos adatokkal, vagy k√©zi
                        be√≠r√°sb√≥l fakad√≥ el√≠r√°sokkal tal√°lkozni, el√©g, ha csak arra gondolunk, hogy a jelenlegi teljes Nobel-d√≠j
                        gy≈ëztes list√°nkban Albert Einstein k√©tszer szerepel, pedig csak egyszert nyert Nobel-d√≠jt, de ak√°r a
                        d√°tumok rosszul form√°zotts√°ga is ide vehet≈ë. Ezeket a probl√©m√°kat mind megkell oldani miel≈ëtt igaz√°n
                        nekifoghatn√°nk a megjelen√≠t√©snek.
                    </p>
                    <p class="text-lg font-normal pb-3">Teh√°t, ez ut√°n m√°r mag√°t√≥l √©rtet≈ëd≈ë, hogy nem lehet al√∫lbecs√ºlni a
                        tiszt√≠t√°si folymatot, √©s alapvet≈ë r√©sz√©t k√©pezi az adat-vizualiz√°ci√≥s folyamatnak, l√©nyeg a l√©nyeg, nagyon
                        hamar mesteriev√© kell v√°lnunk ennek a folyamatnak, hiszen √≠gy a val√≥di vizualiz√°ci√≥ra tudjuk ford√≠tani
                        energi√°nkat. Ahhoz, hogy val√≥ban mesteriev√© v√°ljunk az egyik legfontosabb dolog, hogy a megfelel≈ë
                        eszk√∂z√∂kkel fogunk neki, itt j√∂n k√©pbe a kor√°bban megismert Pandas.
                    </p>
                    <p class="text-lg font-normal pb-3">Hogy √°tism√©telj√ºk azt hol is tartunk jelenleg, van egy JSON √°llom√°nyunk
                        tele a Nobel-d√≠j gy≈ëztesekkel, azok neveivel, nem√©vel, stb., rekord form√°ban bejegyezve, teh√°t, egy t√∂mb,
                        amely objektumokat tartalmaz a relev√°ns adatokkal. Alapvet≈ëen, az a feladatunk ebben a fejezetben, hogy
                        ezen 'dirty' adatb√≥l a lehet≈ë legtiszt√°bb adatot kapjuk az √°ltal, hogy kit√∂r√∂lj√ºk a duplik√°tumokat, a
                        hi√°nyz√≥ mez≈ëket felt√∂ltj√ºk, a nem megfelel≈ë adatt√≠pusokat helyreigaz√≠tsuk, az elrontott mez≈ëket
                        kijav√≠tjuk, a rosszul igaz√≠tott sorokat kijav√≠tjuk, stb.
                    </p>
                    <p class="text-lg font-normal">Els≈ë l√©p√©sben nem m√°st tesz√ºnk, mint bet√∂ltj√ºk a JSON form√°ban lementett
                        adatunkat egy DataFrame-be, ahogy azt az el≈ëz≈ë fejezetekben is l√°thattuk:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">import pandas as pd

# bet√∂ltj√ºk az adatunkat egy DataFrame-be
df_nw_data = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.full.json')</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Mostm√°r helyesebb megold√°s lenne, ha MongoDB-n t√°roln√°nk az adatunkat,
                        elker√ºlve a felesleges f√°jl-menedzsel≈ës probl√©m√°kat, felhaszn√°lva a kor√°bban meg√≠rt hasznos kicsi
                        f√ºggv√©nyeinket. Ugyanakkor, felismert egy probl√©m√°t a k√≥dunkkal, akkor amikor m√°r l√©tez≈ë collection-t
                        t√∂lt√∂k fel, akkor halmozza √©s hozz√°f≈±zi egym√°shoz a bejegyz√©seket, ami a mi eset√ºnkben nem el≈ëny√∂s, teh√°t
                        kieg√©sz√≠tettem a f√ºggv√©nyeket egy √∫jabb param√©terrel, amelyben meghat√°rozhatom azt, hogy a l√©tez≈ë
                        collection-t t√∂r√∂lje, vagy hozz√°f≈±zze, egy egyszer≈± boolean argumentummal:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">import pandas as pd
from pymongo import MongoClient

# alap√©rtelmezett be√°ll√≠t√°sokkal, csup√°n az adatb√°zisn√©v tetsz≈ëleges
def get_mongo_database(db_name, host='localhost', port=27017, username=None, password=None):
    """ El√©rj√ºk a db_name-mel hivatkozott adatb√°zist MongoDB-r≈ël, hiteles√≠t≈ë adatokkal vagy azok n√©lk√ºl """

    if username and password:
        mongo_uri = 'mongodb://{}:{}@{}/{}'.format(username, password, host, db_name)
        # URI = uniform resource identifier
        conn = MongoClient(mongo_uri)
    else:
        conn = MongoClient(host, port)

    return conn[db_name] # itt m√°r a m√°sodik f√©le jel√∂l√©st haszn√°ljuk az adatb√°zis el√©r√©s√©hez

def mongo_to_dataframe(db_name, collection, query={}, host='localhost', port=27017, username=None, password=None, no_id=True):
    """ L√©trehoz egy DataFrame-t egy MongoDB collection-b√≥l """

    db = get_mongo_database(db_name, host, port, username, password)

    # megkeresi a collection-b√≥l a lek√©rdez√©s szerinti elemeket
    cursor = db[collection].find(query)

    df = pd.DataFrame(list(cursor))

    # amennyiben azt szeretn√©nk, hogy t√∂r√∂lje ki a MongoDB √°ltal hozz√°adott id-t
    if no_id:
        del df['_id']

    return df

# alapvet≈ëen, a removeexisting kit√∂rli, ha m√°r l√©tezik,
# a skipifexists, √°tugorja, ha m√°r l√©tezik,
# de a forceupdate eset√©n vagy hozz√°f≈±zi, vagy t√∂rli √©s √∫jrat√∂lti a removeexisting f√ºggv√©ny√©ben
def dataframe_to_mongo(df, db_name, collection, host='localhost', port=27017, username=None, password=None, removeexisting=True, skipifexists=False, forceupdate=False):
    """ Lement egy DataFrame-t egy MongoDB collection-be """

    db = get_mongo_database(db_name, host, port, username, password)

    if (skipifexists and not forceupdate) and (collection in db.list_collection_names()):
        return

    if (collection in db.list_collection_names()) and removeexisting:
        db[collection].drop()

    records = df.to_dict(orient='records')

    db[collection].insert_many(records)

# egy f√ºggv√©nyt hozunk l√©tre, hogy a JSON √°llom√°nyb√≥l a Mongo-ra val√≥ felt√∂lt√©st megk√∂nny√≠tse, √©s majd a tov√°bbiakban
# az adatb√°zison kereszt√ºl fogjuk el√©rni az adatunkat

def upload_data_to_mongo(path, db_name, collection, orient='records', host='localhost', port=27017, username=None, password=None, removeexisting=True, skipifexists=False, forceupdate=False):
    # bet√∂ltj√ºk az adatunkat egy DataFrame-be
    data = pd.read_json(path, orient=orient)

    # felt√∂ltj√ºk mongodb-re az adatokat
    dataframe_to_mongo(data, db_name, collection, host, port, username, password, removeexisting, skipifexists, forceupdate)

upload_data_to_mongo('./nobel_prize/nobel_winners/nobel_winners/nwinners.full.json', db_name='nobel_prize', collection='winners_full', removeexisting=True, skipifexists=True, forceupdate=False)

df = mongo_to_dataframe('nobel_prize', 'winners_full')</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Teh√°t, v√©gre fel van t√∂ltve √©s el is √©rt√ºk a m√©g piszkos adatunkat az
                        adatb√°zisb√≥l, k√∂vetkez≈ë l√©p√©sben vizsg√°ljuk is meg mink van.
                    </p>
                    <p class="text-lg font-normal">A Pandas DataFrame-jei sz√°mos met√≥dussal √©s tulajdons√°ggal rendelkeznek,
                        amelyekkel egy gyors √°ttekint√©st tehet√ºnk az adatainkr√≥l, a leg√°ltal√°nosabb ezek k√∂z√ºl az <em>info</em>
                        met√≥dus, amely √°ltal√°noss√°gban mutatja be azt, hogy h√°ny bejegyz√©s√ºnk van oszloponk√©nt:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.info())

""" output:
<class 'pandas.core.frame.DataFrame'>
RangeIndex: 1136 entries, 0 to 1135
Data columns (total 12 columns):
 #   Column          Non-Null Count  Dtype
---  ------          --------------  -----
 0   link            1136 non-null   object
 1   name            1136 non-null   object
 2   year            1136 non-null   int64
 3   category        1136 non-null   object
 4   country         1136 non-null   object
 5   born_in         1136 non-null   object
 6   text            1136 non-null   object
 7   date_of_birth   1136 non-null   object
 8   date_of_death   1136 non-null   object
 9   place_of_birth  1136 non-null   object
 10  place_of_death  1136 non-null   object
 11  gender          1136 non-null   object
dtypes: int64(1), object(11)
memory usage: 106.6+ KB """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A k√∂nyvt≈ël elt√©r≈ëen, nek√ºnk nincsenek hi√°nyz√≥ bejegyz√©seink, 1136 bejegyz√©s van
                        √∂sszesen, √©s
                        mind az 1136 rendelkezik ugyanazon fejl√©cekkel (mez≈ëkkel). Az info emellett azt is mutatja, hogy mekkora
                        ter√ºletet foglal
                        el a bet√∂lt√∂tt adat a mem√≥ri√°ban. A k√∂vetkez≈ë met√≥dus amir≈ël besz√©ln√ºnk kell a <em>describe</em>, amely
                        egy hasznos statisztikai √∂sszefoglalot szolg√°ltat a relev√°ns oszlopokr√≥l:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.describe())

""" output:
              year
count  1136.000000
mean   1971.781690
std      34.344277
min    1809.000000
25%    1950.000000
50%    1978.000000
75%    2000.000000
max    2019.000000 """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Ahogy azt l√°tni lehet, alap√©rtelmezetten csak a sz√°madatot tartalmaz√≥ oszlopok
                        vannak le√≠rva statisztikailag. M√°r most √©szrevehet≈ë egy hiba az adatunkban, ha a <em>min</em>-re
                        tekint√ºnk, ahol a minimum√©rt√©k az 1809-es √©v, ami lehetetlens√©g, hiszen az els≈ë Nobel-d√≠jt 1901-ben
                        osztott√°k ki. Tov√°bb√°, a describe bevesz egy <em>includes</em> param√©tert is, amely lehet≈ëv√© teszi
                        sz√°munkra, hogy meghat√°rozzuk az oszlop adatt√≠pusait, amelyet vizsg√°lnia kell. A 'year' mez≈ë kiv√©tel√©vel
                        minden tov√°bbi oszlopunk 'object', mint dtype, amely a Pandas alap√©rtelmezetten, catch-all adatt√≠pusa, ami
                        k√©pes b√°rmilyen sz√°madatot, stringet, d√°tumot √©s egyebet is t√°rolni, a k√∂vetkez≈ë p√©lda azt mutatja be,
                        hogy hogyan lehet lek√©rni az ilyen objektumok statisztik√°it:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.describe(include=['object']))

""" output:
                                             link                    name                category        country  ... date_of_death place_of_birth place_of_death gender
count                                          1136                    1136                    1136           1136  ...          1136           1136           1136   1136
unique                                          932                    1059                       7             61  ...           623            649            336      2
top     http://en.wikipedia.org/wiki/Charles_K._Kao  Marie Sk≈Çodowska-Curie  Physiology or Medicine  United States  ...                New York City                  male
freq                                              4                       4                     271            378  ...           364             35            365   1066 """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">√çgy nagyon sok hasznos inform√°ci√≥t voltunk k√©pesek kinyerni az
                        adatainkb√≥l, p√©ldak√©ppen vegy√ºk az orsz√°gok eset√©t, amelyn√©l elmondhat√≥ az, hogy √∂sszesen 61 k√ºl√∂nb√∂z≈ë
                        orsz√°gb√≥l nyertek m√°r Nobel-d√≠jat, legt√∂bbet az AE√Å-b√≥l, sz√°mszerint 378-at. Valamint, szinte biztosan
                        mondhat√≥ az is, hogy vannak duplik√°tumok, hiszen az 1136 n√©vb≈ël, mind√∂ssze 1059 egyedi.
                    </p>
                    <p class="text-lg font-normal">A DataFrame m√°r √°ltalunk sokszor haszn√°lt k√∂vetkez≈ë met√≥dusa a <em>head</em>,
                        √©s a m√©g nem ismert <em>tail</em>, amelyek ugyancsak nagyon hasznosak lehetnek, ha egy gyors √°ttekint√©st
                        akarunk adatainkr√≥l:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.tail())

""" output: 
                                                   link                   name  year                category  ...      date_of_death place_of_birth      place_of_death gender
1131  http://en.wikipedia.org/wiki/Adolfo_P%C3%A9rez...  Adolfo P√©rez Esquivel  1980                   Peace  ...                      Buenos Aires                       male
1132  http://en.wikipedia.org/wiki/Luis_Federico_Leloir   Luis Federico Leloir  1970               Chemistry  ...    2 December 1987          Paris  Catamarca Province   male
1133      http://en.wikipedia.org/wiki/Bernardo_Houssay       Bernardo Houssay  1947  Physiology or Medicine  ...  21 September 1971   Buenos Aires        Buenos Aires   male
1134  http://en.wikipedia.org/wiki/Carlos_Saavedra_L...  Carlos Saavedra Lamas  1936                   Peace  ...         5 May 1959   Buenos Aires        Buenos Aires   male
1135         http://en.wikipedia.org/wiki/Brian_Schmidt          Brian Schmidt  2011                 Physics  ...                          Missoula                       male """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Alap√©rtelmezetten, mindk√©t met√≥dus az els≈ë, vagy utols√≥ 5-√∂t √≠rja ki, de
                        argumentumk√©nt meghat√°rozhatjuk ezt a sz√°mot. Mik√∂zben vizsg√°ltuk az adatokat, k√©pesek voltunk √©szrevenni,
                        hogy bizonyos nevek tartalmazz√°k a csillagot (*), mert m√°s orsz√°gban sz√ºlettek, mint amelynek
                        √°llampolg√°rai voltak mikor megnyert√©k a Nobel-d√≠jt. Valamint, a jelenlegi adatokb√≥l nem l√°tszik, de
                        val√≥j√°ban a d√°tum form√°tumok sem egys√©gesek, a tov√°bbiakban azzal is foglalkoznunk kell. V√©g√ºl, szeretn√©nk
                        megvizsg√°lni azt, hogy h√°nyszor jelenik meg a 'born_in' mez≈ë √ºresen, azonban probl√©m√°ba √ºtk√∂z√ºnk:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(len(df[df.born_in == ''])) # output: 995</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Kiv√°lasztva a csoportot, megtudhatjuk azt, hogy 995 √ºres born_in mez≈ë van,
                        a
                        sz√°mmal m√©g nem lenne semmi gond sem, azonban minket val√≥j√°ban nem √©rdekel az, hogy h√°ny √ºres van, hanem
                        pontosan az √©rdekelne a born_in kapcs√°n, hogy h√°nynak nem egyezik meg a 'country' a 'born_in'-nel, teh√°t
                        az √ºres 'born_in' √©rt√©ket lek√©ne cser√©lni valami olyanra, amit a Pandas nem sz√°mol meg, mert tudja, hogy
                        nem relev√°ns.
                    </p>
                    <p class="text-lg font-normal pb-3">Miel≈ëtt nekifogn√°nk, hogy megtiszt√≠tsuk az adatunkat, kicsit ism√©telj√ºk √°t
                        azt, hogy hogyan is tudunk adatot kiv√°lasztani a Pandas-al, haszn√°lva a Nobel-d√≠jas adatsorunkat.
                    </p>
                    <p class="text-lg font-normal">A Pandas sor √©s oszlop szerint indexel. √Åltal√°ban az oszlop indexek az
                        adatf√°jlban ker√ºlnek meghat√°roz√°sra, SQL t√°bl√°kban, vagy b√°rmi m√°sban, de ahogy azt kor√°bban is l√°thattuk
                        a kik√∂vetkeztett oszlop indexet fel√ºl is √≠rhatjuk amikor l√©trehozzuk a DataFrame-t egy names
                        argumentummal, a l√©trehozott oszlop indexek megtekinthet≈ëek, mint DataFrame tulajdons√°g:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.columns)

""" output:
Index(['link', 'name', 'year', 'category', 'country', 'born_in', 'text',
       'date_of_birth', 'date_of_death', 'place_of_birth', 'place_of_death',
       'gender'],
      dtype='object') """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Alap√©rtelmezetten sorindexek eset√©n, a Pandas nulla-alap√∫ eg√©sz √©rt√©k≈±
                        indexel√©st haszn√°l, de ezt is fel√ºl√≠rhatjuk, az √°ltal, hogy meghat√°rozzuk azt egy index param√©terben a
                        DataFrame l√©trehoz√°sakor, vagy ak√°r ut√≥lag is, ugyancsak az index tulajdons√°ggal. A legnagyobb
                        gyakoris√°ggal egy vagy t√∂bb oszlopot szeretn√©nk haszn√°lni, mint sorindex. Megtehetj√ºk ezt a m√°r haszn√°lt
                        set_index met√≥dussal, tov√°bb√°, ha vissza szeretn√©nk t√©rni az alap√©rtelmezett sz√°mindexel√©sre,
                        haszn√°lhatjuk a reset_index met√≥dust:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = df.set_index('name')
print(df.head(2))

""" output:
                                                           link  year                category  country  ... date_of_death place_of_birth place_of_death  gender
name                                                                                                    ...
Eric Kandel *          http://en.wikipedia.org/wiki/Eric_Kandel  2000  Physiology or Medicine           ...                       Vienna                   male
Elfriede Jelinek  http://en.wikipedia.org/wiki/Elfriede_Jelinek  2004              Literature  Austria  ...                 M√ºrzzuschlag                 female """

df = df.reset_index()
print(df.head(2))

""" output:
               name                                           link  year                category  ... date_of_death place_of_birth place_of_death  gender
0     Eric Kandel *       http://en.wikipedia.org/wiki/Eric_Kandel  2000  Physiology or Medicine  ...                       Vienna                   male
1  Elfriede Jelinek  http://en.wikipedia.org/wiki/Elfriede_Jelinek  2004              Literature  ...                 M√ºrzzuschlag                 female """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">√ârdekess√©g, hogy a legt√∂bb met√≥dus rendelkezik egy <em>inplace</em>
                        argumentummal, amellyel meghat√°rozhatjuk azt, hogy egy √∫j objektumot t√©r√≠tsen-e vissza, vagy a haszn√°ltat
                        m√≥dos√≠tsa.
                    </p>
                    <p class="text-lg font-normal">Mivel, most m√°r √©rts√ºk a Pandas t√°bl√°zatos, sorral √©s oszloppal, t√∂rt√©n≈ë
                        indexel√©s√©t, ak√°r neki is foghatunk darabokat kiragadni a DateFrame-√ºnkb≈ël. K√©pesek vagyunk egy oszlopot
                        kiv√°lasztani a DataFrame-b≈ël a pot jel√∂l√©st haszn√°lva (term√©szetesen, azokn√°l az oszlopokn√°l, ahogy nincs
                        sz√≥k√∂z vagy egy√©b speci√°lis karakter) vagy egy√©b esetekben a t√∂mbszer≈± jel√∂l√©ssel is. Vegy√ºk el≈ë megint a
                        born_in oszlopot:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">bi_col = df.born_in
print(bi_col)
print(type(bi_col))

""" output: 
0              Austria
1
2
3
4       Czech Republic
             ...
1131
1132
1133
1134
1135
Name: born_in, Length: 1136, dtype: object
&#60;class 'pandas.core.series.Series'> """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">A t√≠pusn√°l megfigyelhet≈ë az, hogy az oszlopkiv√°laszt√°s egy Series-t t√©r√≠t
                        vissza, amely meg≈ërzi az eredeti DataFrame indexel√©s√©t.
                    </p>
                    <p class="text-lg font-normal">A DataFrame-k √©s Seris-ek ugyanazokkal a met√≥dusokkal rendelkeznek, hogy
                        el√©rj√©k oszlopaikat/soraikat. Az iloc eg√©sz poz√≠ci√≥ alapj√°n v√°laszt ki, a loc c√≠mke szerint, a legfrisebb
                        Pandas verzi√≥kban m√°r csak ez a k√©t t√≠pus√∫ kiv√°laszt√°s lehets√©ges:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># el√©rj√ºk az els≈ë sort
print(df.iloc[0])

""" output:
link                 http://en.wikipedia.org/wiki/Eric_Kandel
name                                            Eric Kandel *
year                                                     2000
category                               Physiology or Medicine
country
born_in                                               Austria
text              Eric Kandel *, Physiology or Medicine, 2000
date_of_birth                                 7 November 1929
date_of_death
place_of_birth                                         Vienna
place_of_death
gender                                                   male """

df.set_index('name', inplace=True)
print(df.loc['Albert Einstein'])

""" output:
link year category country born_in ... date_of_birth date_of_death place_of_birth place_of_death gender
name ...
Albert Einstein http://en.wikipedia.org/wiki/Albert_Einstein 1921 Physics Switzerland ... 14 March 1879 18 April 1955 Ulm
Princeton male
Albert Einstein http://en.wikipedia.org/wiki/Albert_Einstein 1921 Physics Germany ... 14 March 1879 18 April 1955 Ulm Princeton
male """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">√öjabb hib√°t fedezhett√ºnk fel, Albert Einstein k√©tszer jelenik meg,
                        egyszer, mint sv√°jci sz√ºlet√©s≈±, egyszer meg, mint n√©met. Tov√°bbi √©rdekess√©g, √≠gy lehet t√∂bb szempont
                        szerinti kiv√°laszt√°st v√©gezni:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df[(df.gender == 'male') & (df.category == 'Literature')])

""" output:
                                                   link                 name  year    category  ...      date_of_death place_of_birth place_of_death gender
37    http://en.wikipedia.org/wiki/Czes%C5%82aw_Mi%C...     Czes≈Çaw Mi≈Çosz *  1980  Literature  ...     14 August 2004       ≈†eteniai         Krak√≥w   male
40          http://en.wikipedia.org/wiki/John_Steinbeck       John Steinbeck  1962  Literature  ...   20 December 1968        Salinas         Harlem   male
60          http://en.wikipedia.org/wiki/Sinclair_Lewis       Sinclair Lewis  1930  Literature  ...    10 January 1951    Sauk Centre           Rome   male
67        http://en.wikipedia.org/wiki/Eugene_O%27Neill       Eugene O'Neill  1936  Literature  ...   27 November 1953  New York City         Boston   male
74        http://en.wikipedia.org/wiki/William_Faulkner     William Faulkner  1949  Literature  ...        6 July 1962     New Albany        Byhalia   male
...                                                 ...                  ...   ...         ...  ...                ...            ...            ...    ...
1077          http://en.wikipedia.org/wiki/Pablo_Neruda         Pablo Neruda  1971  Literature  ...  23 September 1973         Parral       Santiago   male
1085           http://en.wikipedia.org/wiki/Saul_Bellow        Saul Bellow *  1976  Literature  ...       5 April 2005        Lachine      Brookline   male
1097       http://en.wikipedia.org/wiki/Ivo_Andri%C4%87         Ivo Andriƒá *  1961  Literature  ...      13 March 1975          Dolac       Belgrade   male
1101         http://en.wikipedia.org/wiki/Elias_Canetti      Elias Canetti *  1981  Literature  ...     14 August 1994           Ruse         Z√ºrich   male
1114   http://en.wikipedia.org/wiki/Maurice_Maeterlinck  Maurice Maeterlinck  1911  Literature  ...         6 May 1949          Ghent           Nice   male """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A szabv√°ny Python slice-ol√°s haszn√°lhat√≥ DataFramek eset√©n is, hogy t√∂bb sort
                        tudjunk kiv√°lasztani:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># √≠rja ki a 10-edik √©s 25-ik sor k√∂z√∂tti sorokat
print(df[10:25])</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Az el≈ëbb m√°r l√°that√≥ volt hogyan lehet boolean maskot haszn√°lni arra, hogy
                        sorokat v√°lasszunk ki:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># ki√≠rja azon gy≈ëztesek sz√°m√°t, akik n≈ëk voltak √©s irodalom kateg√≥ri√°ban nyertek
print(df[(df.gender == 'female') & (df.category == 'Literature')].count())</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Mostm√°r tudjuk azt, hogy hogyan tudunk a DataFrame-√ºnkb≈ël adatokat
                        kiv√°lasztani, ak√°r legyen az t√∂bb sor, vagy egyetlen. Els≈ëk√©nt, foglalkozzunk az √ºres born_in mez≈ëkkel,
                        amelyeket kor√°bban felismert√ºnk √©s teljes m√©rt√©kben hib√°sak, a mi eset√ºnkben legal√°bbis.
                    </p>
                    <p class="text-lg font-normal">Ha megsz√°moljuk a born_in mez≈ëket, felismerhetj√ºk azt, hogy t√∫l sok van
                        bel≈ël√ºk, nem hi√°nyzik, ami nem t√∂rt√©nne meg, ha hi√°nyozna az a mez≈ë, vagy, ha NaN lenne:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.born_in.describe())

""" output:
count     1136
unique      42
top
freq       995
Name: born_in, dtype: object """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Teh√°t, 1136-szor jelenik meg a born_in mez≈ë, illet≈ëleg abb√≥l 995-sz√∂r
                        √ºresen, s mind√∂ssze 42 k√ºl√∂nb√∂z≈ë, egyedi √©rt√©k van ebben a mez≈ëben.
                    </p>
                    <p class="text-lg font-normal">Fontos megjegyezni azt, hogy a Pandas b√°rmif√©le stringhez hasonl√≥ adatot
                        'object'-ben t√°rol. A vizsg√°latunk kimutatta azt, hogy a born_in oszlopunk felv√°ltva tartalmaz √ºres,
                        illet≈ëleg orsz√°gnevet tartalmaz√≥ stringeket. Gyorsan k√©pesek vagyunk azt is megvizsg√°lni, hogy mindenik
                        oszlop tag Unicode-e, az √°ltal, hogy map-elj√ºk mindegyik taghoz a type funkci√≥t, az <em>apply</em>
                        met√≥dussal, √©s v√©g√ºl egy set-be helyezz√ºk az eg√©szet, hogy csakis a k√ºl√∂nb√∂z≈ë elemek maradjanak:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(set(df.born_in.apply(type)))
# output: {&#60;class 'str'>}</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">A k√≥d r√°mutat arra, hogy mindegyik oszloptagunk egy string. Most
                        kicser√©lhetj√ºk az √∂sszes √ºres stringet egy √ºres mez≈ëvel, amit m√°r a Pandas nem fog sz√°m√≠t√°sba venni,
                        amikor statisztik√°kat ker√ºnk le az adatainkr√≥l.
                    </p>
                    <p class="text-lg font-normal">Teh√°t, leszeretn√©nk cser√©lni az √∂sszes √ºres stringet egy NaN-al, hogy
                        megel≈ëzz√ºk azt, hogy megsz√°molj√°k. Szerencs√©re a Pandas <em>replace</em> met√≥dust pont erre hozt√°k l√©tre,
                        √©s k√©pesek vagyunk DataFrame-ra, vagy ak√°r Series-re is alkalmazni:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">import numpy as np

bi_col = df.born_in
bi_col.replace('', np.nan, inplace=True)
print(bi_col.describe())

""" output:
count         141
unique         41
top       Germany
freq           25 """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Mostm√°r, hogy lecser√©lt√ºk az √ºres Stringeket, megkapjuk a val√≥s sz√°m√°t a
                        born_in mez≈ëknek, ami 141 darab, ahol N√©metorsz√°g a leggyakoribb, 25-sz√∂r jelenik meg. Ezut√°n, ak√°r a
                        teljes DataFrame-re n√©zve is megtehetj√ºk ezt, lecser√©lve minden megsz√°molt √ºres √©rt√©ket, megsz√°ml√°latlan
                        NaN-ra:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df.replace('', np.nan, inplace=True)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A Pandas lehet≈ëv√© teszi azt, hogy stringeket cser√©lj√ºnk le (de ak√°r egy
                        object-eket is) az oszlopokban (ak√°r regExp-ek haszn√°lat√°t is lehet≈ëv√© teszi, amelyek a Series-ekre
                        lesznek alkalmazva, amelyek ahogy kor√°bban is l√°thattuk, √°ltal√°ban a DataFrame-k oszlopait alkotj√°k). A
                        k√∂vetkez≈ë p√©ld√°ban n√©zz√ºk meg azt, hogy hogyan vagyunk k√©pesek kit√∂r√∂lni a felesleges csillagokat a
                        Nobel-gy≈ëztesek neveib≈ël, valamint a felesleges whitespaceket is. A Pandas Series-eknek van egy nagyon
                        hasznos <em>str</em> met√≥dusuk, amelyek lehet≈ëv√© teszik, hogy j√≥n√©h√°ny string met√≥dust hajtsuk v√©gre egy
                        t√∂mb√∂n, el≈ësz√∂ris n√©zz√ºk meg mely neveket tartalmaznak csillagot:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># az√©rt van sz√ºks√©g az escape-re a csillag el≈ëtt, mert ez egy regExp string
print(df[df.name.str.contains('\*')]['name'])

""" output:
0                Eric Kandel *
4         Bertha von Suttner *
5       Luis Federico Leloir *
14            Yoichiro Nambu *
37            Czes≈Çaw Mi≈Çosz *
                 ...
1098         Vladimir Prelog *
1099           Peter Medawar *
1101           Elias Canetti *
1104          Zhores Alferov *
1122     Elizabeth Blackburn * """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Ahhoz, hogy megtiszt√≠tsuk a neveket a csillagt√≥l √©s egy√©b felesleges dologt√≥l,
                        haszn√°lhatjuk megint a replace met√≥dust, valamint a <em>strip</em>-et:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df.name = df.name.str.replace('*', '')
df.name = df.name.str.strip()

print(df[df.name.str.contains('\*')]['name'])
# output: √ºres</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">√Ått√©rhet√ºnk a sorok t√∂rl√©s√©re, hiszen m√©g mindig 141 olyan gy≈ëztes√ºnk van,
                        ahol megjelenik a born_in mez≈ë, hiszen k√©tszer vannak be√≠rva a Wikip√©di√°n, egyszer ann√°l az orsz√°gn√°l,
                        ahol sz√ºlettek, illet≈ëleg ann√°l az orsz√°gn√°l is, amilyen nemzetis√©g√ºek voltak mikor megnyert√©k a d√≠jat.
                        Szeretn√©nk l√©trehozni egy √∫j DataFrame-t, amely csak azokat a sorokat tartalmazza, ahol a born_in mez≈ë
                        NaN, teh√°t √ºres. Azt hinn√©k, hogy egyszer≈± √∂sszehasonl√≠t√°s megteszi, a born_in mez≈ëre alkalmazva, azonban
                        a Python eset√©ben a NaN-al val√≥ logikai kifejez√©s mindig Hamisra √©rt√©kel≈ëdik ki.
                    </p>
                    <p class="text-lg font-normal">Ennek eredm√©nyek√©ppen a Pandas biztos√≠t egy erre szakosodott <em>isnull</em>
                        met√≥dust, amellyel leellen≈ër√≠zhetj√ºk a null mez≈ëket:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = df[df.born_in.isnull()]
print(df.count())

""" output:
link              995
name              995
year              995
category          995
country           995
born_in             0
text              995
date_of_birth     995
date_of_death     675
place_of_birth    995
place_of_death    674
gender            995 """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Teh√°t, miut√°n kiv√°lasztottuk ezeket a sorokat, ak√°r el is vethetj√ºk a born_in
                        oszlopot, mert nincs r√° t√∂bb√© sz√ºks√©g, a <em>drop</em> met√≥dussal:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># az axis=0 sort jel√∂l, az axis=1 oszlopot jel√∂l
df = df.drop('born_in', axis=1)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Egy gyors Google keres√©ssel kider√≠thetj√ºk azt, hogy 2019-ig 950 szem√©ly √©s
                        egyes√ºlet nyert Nobel-d√≠jat, teh√°t 995 sorunk van jelenleg, ami kicsit sok, megkell keresn√ºnk a
                        duplik√°tumokat, vagy egy√©b rendellenes√©geket, amik az elt√©r√©st okozhatj√°k.
                    </p>
                    <p class="text-lg font-normal">A Pandas rendelkezik egy hasznos <em>duplicated</em> met√≥dussal, amely
                        seg√≠ts√©g√©vel megkereshet√ºnk egyez≈ë sorokat. Ez egyez≈ë sorokat keres oszlopn√©v szerint, lehet ak√°r t√∂bb is,
                        √©s abban az oszlopban keres duplik√°tumokat:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># megkeresi a name oszlopban az egyez≈ë sorokat
dupes_by_name = df[df.duplicated('name')]
print(dupes_by_name.count())
# output: 70 ...</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Teh√°t, a fenti keres√©s r√°mutatott arra, hogy 70 duplik√°tum bejegyz√©s√ºnk
                        van, egy gyors kivon√°s ut√°n 995-70=925, ami m√©g mindig 2-vel t√∂bb, mint ah√°ny szem√©ly valaha Nobel-d√≠jat
                        nyert. Persze, ebben az esetben sz√°molnunk kell azzal is, hogy vannak olyan szem√©lyek, akik t√∂bbsz√∂r
                        nyertek Nobel-d√≠jat, ilyen p√©ld√°ul Marie Curie is.
                    </p>
                    <p class="text-lg font-normal pb-3">A k√∂vetkez≈ëkben n√©zz√ºnk meg n√©h√°ny m√≥dot arra, hogy megtal√°ljuk
                        t√©nylegesen azokat az elemeket n√©vszerint, amelyek duplik√°tumok. N√©melyik√ºk kev√©sb√© hat√©kony, azonban
                        nagyon j√≥ megk√∂zel√≠t√©s arra, hogy m√©gjobban megismerj√ºk a Pandas f√ºggv√©nyeit.
                    </p>
                    <p class="text-lg font-normal">Alap√©rtelmezetten, a duplicated met√≥dus a duplik√°tumokat √∫gy sz√°molja, hogy az
                        els≈ë megjelen√©s√©t nem jel√∂li annak, de a t√∂bbit igen, nam√°r most, a <em>keep</em> argumentum
                        felhaszn√°l√°s√°val megkaphatjuk az √∂sszes duplik√°tumot, amikoris, m√°r egyet sem hagy ki:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">all_dupes = df[df.duplicated('name', keep=False)]
print(all_dupes.count())
# output: 136 ...</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Az √°ltal is megkaphatjuk a duplik√°tumokat, hogy megn√©zz√ºk mely sorok vannak be
                        a duplik√°tum n√©vlist√°nkban a k√∂vetkez≈ëk√©ppen, felhaszn√°lva a Pandas <em>isin</em> met√≥dus√°t:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">dupes_by_name = df[df.duplicated('name')]
all_dupes = df[df.name.isin(dupes_by_name.name)]
print(all_dupes.count())
# output: 136</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A duplik√°tumokat a Pandas groupby met√≥dus√°val is megtal√°lhatjuk, amely a
                        DataFrame sorait oszlopok szerint csoportos√≠tja, visszat√©r√≠t egy key-value p√°rt, az oszlop √©rt√©k√©vel, mint
                        kulcs, valamint a sorok list√°j√°val, mint √©rt√©k:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">for name, rows in df.groupby('name'):
    print('name: {}, number of rows: {}'.format(name, len(rows)))</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A fenti rendszert elhaszn√°lva, ahhoz, hogy megkapjuk az √∂sszes duplik√°tum sort,
                        igaz√°b√≥l csak a visszat√©r√≠tett lista hossz√°t kell megn√©zn√ºnk. B√°rmi, ami nagyobb, mint 1, azt jelenti,
                        hogy l√©tezik n√©vduplik√°tumja. A k√∂vetkez≈ë esetben a Panda concat met√≥dus√°t fogjuk haszn√°lni, amely bevesz
                        egy list√°nyi sort √©s l√©trehoz √≠gy egy DataFrame-t a duplik√°tum sorokb√≥l:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">tmp = pd.concat([g for _, g in df.groupby('name') if len(g) > 1])
print(tmp['name'])

""" output:
19             Alan MacDiarmid
708            Alan MacDiarmid
559            Albert Einstein
812            Albert Einstein
406               Angus Deaton
                 ...
1017    William Lawrence Bragg
643          W≈Çadys≈Çaw Reymont
675          W≈Çadys≈Çaw Reymont
222                Yuan T. Lee
567                Yuan T. Lee """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Mostm√°r, hogy rendelkez√ºnk az all_dupes DataFrame-el, benne minden n√©vszerint
                        duplik√°tum sorral, haszn√°lhatjuk, hogy demonstr√°ljuk a Pandas <em>sort</em> met√≥dus√°t. A met√≥dus biztos√≠t
                        egy kifinomult rendez√©si met√≥dust a DataFrame, illetve Series classokhoz, amely k√©pes t√∂bb oszlop szerint
                        rendezni az elemeket:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df2 = pd.DataFrame({'name': ['zak', 'alice', 'bob', 'mike', 'bob', 'bob'],
    'score': [4, 3, 5, 2, 3, 7]})

# a megadott DataFrame-t k√©t oszlop szerint rendezi, el≈ësz√∂ris a n√©v oszlop szerint, amennyiben annak az √©rt√©ke megegyezik,
# ut√°na cs√∂kken≈ë sorrendben a pontuk alapj√°n rendezi
print(df2.sort_values(['name', 'score'], ascending=[1, 0]))</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Ennek tudat√°ban rendezz√ºk az all_dupes DataFrame-√ºnket n√©v szerint, azt√°n
                        vizsg√°ljuk meg:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(all_dupes.sort_values('name')[['name', 'country', 'year']])

""" output: 
                        name                  country  year
708          Alan MacDiarmid              New Zealand  2000
19           Alan MacDiarmid            United States  2000
812          Albert Einstein                  Germany  1921
559          Albert Einstein              Switzerland  1921
538             Angus Deaton           United Kingdom  2015
...                      ...                      ...   ...
1017  William Lawrence Bragg                Australia  1915
675        W≈Çadys≈Çaw Reymont                   Poland  1924
643        W≈Çadys≈Çaw Reymont  Russia and Soviet Union  1924
567              Yuan T. Lee                   Taiwan  1986
222              Yuan T. Lee            United States  1986 """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Az output meg is mutatja feltev√©s√ºnket, hogy egyes gy≈ëzteseket k√ºl√∂nb√∂z≈ë
                        orsz√°gokn√°l de egyazon gy≈ëzelem miatt ker√ºltek bejegyz√©se az oldalon, √≠gy a mi adatsorunk is hib√°s lett.
                    </p>
                    <p class="text-lg font-normal">Teh√°t, valamilyen m√≥don megkell szabadulnunk a duplik√°tumokt√≥l, ehhez egy
                        tiszt√≠t√≥ f√ºggv√©nyt fogunk l√©trehozni. Azonban, el≈ësz√∂ris megkell besz√©ln√ºnk a k√ºl√∂nbs√©get a view √©s copy
                        k√∂z√∂tt. Nagyon fontos, amikor Pandas-al dolgozunk, hogy tiszt√°ban legy√ºnk azzal, hogy egy view-j√°t vagy
                        m√°solat√°t v√°ltoztatjuk a DataFrame-√ºnknek, vagy Series-√ºnknek. A k√∂vetkez≈ë megk√∂zel√≠t√©s nagyon
                        term√©szetesnek t≈±nhet, hogy megv√°ltoztassuk a t√°bl√°zatunk egy cell√°j√°t:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df['country'][708] = 'United States'

""" output:
A value is trying to be set on a copy of a slice from a DataFrame

See the caveats in the documentation: https://pandas.pydata.org/pandas-docs/stable/user_guide/indexing.html#returning-a-view-versus-a-copy
  df['country'][708] = 'United States' """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">De, ahogy l√°that√≥ hiba√ºzentet kapunk, ugyanakkor m√©g jobban √∂sszezavarhat
                        minket az is, hogy val√≥j√°ban j√≥l v√°ltoztatta meg a cella√©rt√©ket:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df['country'][708])
# output: United States</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Ahogy kider√ºl, a Pandas fejleszt≈ëi val√≥j√°ban ezekkel a hiba√ºzenetekkel
                        elakarnak b√°tor√≠tani a hasonl√≥ m≈±veletl√°ncolatok ir√°s√°t√≥l, mert nagyon k√∂nny≈± vel√ºk abba a hib√°ba esni,
                        hogy val√≥j√°ban az eredeti DataFrame egy m√°solat√°t m√≥dos√≠tsuk az eredeti helyett. A best-practice az
                        eml√≠tett megold√°s helyett az lenne, ha a loc vagy iloc met√≥dust haszn√°ln√°nk √©s az alapj√°n m√≥dos√≠tan√°nk a
                        cella √©rt√©k√©t:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df.loc[708, 'country'] = 'United States'

print(df.loc[708])</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Egy robusztusabb megold√°s arra, hogy megv√°ltoztassuk egy sor orsz√°g√°t az, ha
                        stabil oszlop √©rt√©keket haszn√°lunk, hogy kiv√°lasszuk a sort annak indexe helyett. Ahhoz, hogy
                        megv√°ltoztassuk Alan MacDiarmid orsz√°g√°t √öj-Z√©landr√≥l AE√Å-ra, haszn√°lhatunk egy boolean maskot a loc
                        met√≥dussal egy√ºtt, hogy kiv√°lasszuk a sort, majd be√°ll√≠tsuk az orsz√°g oszlop√©rt√©ket az AE√Å-ra:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df.loc[(df.name == 'Alan MacDiarmid') & (df.year == 2000), 'country'] = 'United States'
print(df.loc[(df.name == 'Alan MacDiarmid') & (df.year == 2000), 'country']) # output: United States (k√©tszer)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Ugyanakkor, mi nem m√°st szeretn√©nk mint, hogy eltudjunk vetni bizonyos
                        sorokat
                        az oszlop√©rt√©kek alapj√°n, hiszen t√∂bbsz√∂r jelennek meg, mint ah√°nyszor indokolt lenne. K√©t m√≥dszer √°ll
                        rendelkez√©s√ºnkre ennek a megold√°s√°ra, az els≈ë a DataFrame <em>drop</em> met√≥dus√°t haszn√°lja, amely bevesz
                        egy list√°nyi index c√≠mk√©t, vagy a m√°sodik megk√∂zel√≠t√©s, hogy l√©trehozunk egy √∫j DataFrame-t egy boolean
                        mask-al, amely kisz≈±ri a duplik√°tum sorokat, teh√°t azokat, amelyeket elszeretn√©nk vetni.
                    </p>
                    <p class="text-lg font-normal">A k√∂vetkez≈ë k√≥dr√©szlet azt mutatja be, hogy hogyan fogjuk a duplik√°tum Alan
                        MacDiarmid sort elvetni, l√©trehozva egy √∫j DataFrame-t egyetlen ilyen nev≈± sorral:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df.drop(df[(df.name == 'Alan MacDiarmid') & (df.year == 2000)].index, inplace=True)
# azonban kit√∂rli az √∂sszes olyan sort, amelyben a fenti mask teljes√ºl</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A k√∂vetkez≈ë m√≥d, hogy l√©trehozunk egy √∫j DataFrame-t, haszn√°lva az el≈ëbbi
                        boolean mask-ot, azonban ebben az esetben a logikai nem (~) oper√°torral egy√ºtt, az √∫j DataFrame minden
                        sort tartalmazni fog, kiv√©ve azt amit kiv√°lasztunk:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = df[~((df.name == 'Alan MacDiarmid') & (df.year == 2000))]
# ebben az esetben is kit√∂rli az √∂sszeset</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Jelenleg az a probl√©m√°nk a duplik√°tumok t√∂rl√©s√©vel, hogy mindenik sort kit√∂rli,
                        amely eset√©ben a mask teljes√ºl. Persze, ezekkel is meglehetne oldani, az els≈ën√©l, mivel egy MultiIndex-et
                        t√©r√≠t vissza, kiv√°laszthatn√°nk melyiket akarjuk t√∂r√∂lni, de √≠gy a megold√°s robusztuss√°ga odaveszett.
                        Szerencs√©re, a Pandas okosan gondolt a probl√©m√°nkra, hiszen rendelkezik egy √∫n. <em>drop_duplicates</em>
                        met√≥dussal, amely visszat√©r√≠t egy √∫j DataFrame-t kit√∂r√∂lve a duplik√°tumokat, valamelyik oszlop szerint:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df.drop_duplicates('name', inplace=True)
print(df[df.name == 'Marie Curie'])</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">De, a fenti met√≥dus eset√©ben tov√°bbi probl√©m√°ba √ºtk√∂zt√ºnk, hiszen n√©v szerinti
                        duplik√°tumoka t√∂r√∂lt√ºnk, √≠gy azok a szem√©lyek is t√∂r√∂lve lettek, akik t√∂bbsz√∂r nyertek Nobel-d√≠jat. Teh√°t,
                        tal√°lnunk kell egy relev√°nsabb szempontot:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># ha nem hat√°rozunk meg oszlopot, abban az esetben az √∂sszes alapj√°n fog duplik√°tumot keresni,
# ebben az esetben j√≥l hagyja meg Curie-t, azonban MacDiarmid-et nem t√∂rli, hiszen a bejegyz√©sekben van elt√©r√©s, az orsz√°gn√°l
""" df.drop_duplicates(inplace=True)
print(df[df.name == 'Marie Curie'])
print(df[df.name == 'Alan MacDiarmid']) """

# ebben az esetben m√°r ≈±gy t√ºnik sikeres a duplik√°tum t√∂rl√©s, hiszen Curie megmaradt, MacDiarmid pedig t√∂rl≈ëd√∂tt
df.drop_duplicates(['name', 'year'], inplace=True)
print(df[df.name == 'Marie Curie'])
print(df[df.name == 'Alan MacDiarmid'])</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Az ezt megel≈ëz≈ë l√©pes ut√°n megint megvizsg√°lhatjuk, hogy mennyire sikeres a
                        duplik√°tumok t√∂rl√©se:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># minden rendben van, kiv√©ve, hogy most vehett√ºk √©szre, hogy k√©t Curie-nk van, a m√°sodik felesleges teh√°t azt is t√∂r√∂lhetj√ºk
print(df[df.duplicated('name', keep=False)].sort_values('name')[['name', 'country', 'year']])</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Viszonylag egyszer≈±en orvosolhat√≥ a dupla Curie probl√©ma, egyszer≈±en a lengyel
                        bet≈±ket tartalmaz√≥ sort elvethetj√ºk, √©s kiz√°r√≥lag a francia Curie-t benthagyva az adatsorban:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df.drop(df[(df.name == u'Marie Sk\u0142odowska-Curie')].index, inplace=True)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Mostm√°r, legjobb megfigyel√©s√ºnk szerint nincs duplik√°tum, olyan
                        duplik√°tum, amely eset√©n ugyanazon Nobel-d√≠j miatt szerepelne az adatsorban. Vannak olyan nevek, amelyek
                        k√©tszer szerepelnek, de kiz√°r√≥lag az√©rt, mert k√©t k√ºl√∂nb√∂z≈ë √©vben nyertek Nobel-d√≠jt.
                    </p>
                    <p class="text-lg font-normal">√ñsszefoglalva az eddigi tiszt√≠t√°sunkat, hozzunk l√©tre ehhez egy f√ºggv√©nyt, hogy
                        egyetlen helyen letudjuk h√≠vni:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">def clean_data(df):
    # els≈ë l√©p√©sben, az √∂sszes √ºres √©rt√©ket NaN-ra √°ll√≠tjuk, hogy a Pandas a statisztik√°k sor√°n nem sz√°molja
    df = df.replace("", np.nan)
    # m√°sodik l√©p√©sben, az √∂sszes olyan sort t√∂r√∂lj√ºk a DataFrame-b≈ël, amelyn√©l a born_in nem volt √ºres, azaz nem volt NaN
    df = df[df.born_in.isnull()]
    # harmadik l√©p√©sben, t√∂r√∂lj√ºk a born_in oszlopot, hiszen nem relev√°ns, nincs egy olyan sor sem, amely √©rt√©ket t√°rolna ott
    df = df.drop("born_in", axis=1)
    # kieg√©sz√≠t≈ë l√©p√©sekben t√∂r√∂lj√ºk a csillagokat √©s a felesleges space-t a nevekb≈ël
    df.name = df.name.str.replace("*", "")
    df.name = df.name.str.strip()
    # negyedik l√©p√©sben t√∂r√∂lj√ºk a duplik√°tumokat, k√©t relev√°ns szempont szerint, ami els≈ëk√©nt a n√©v, majd az √©v,
    # azokat t√∂rli, ahol mindkett≈ë megegyezik, √≠gy elker√ºlve azt, hogy olyant t√∂r√∂lj√ºnk aki k√©tszert nyert
    df = df.drop_duplicates(['name', 'year'])
    # t√∂r√∂lj√ºk a duplik√°tum lengyel karakteres Curie-t
    df = df.drop(df[(df.name == u'Marie Sk\u0142odowska-Curie')].index)
    # t√∂r√∂lj√ºk a rossz d√°tummal fel√≠rt Ragnar Granit-ot is
    df = df.drop(df[(df.name == 'Ragnar Granit') & (df.year == 1809)].index)
    # jav√≠tjuk az elhib√°zott 1809-es d√°tumokat
    df.loc[(df.name == 'Artturi Ilmari Virtanen') & (df.year == 1809), 'year'] = 1945
    df.loc[(df.name == u'Frans Eemil Sillanp\u00E4\u00E4') & (df.year == 1809), 'year'] = 1939

    return df

df = clean_data(df)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">M√°r el√©g j√≥l haladunk, √∂sszesen 928 gy≈ëztes√ºnk, bele√©rtve azokat is, akik
                        t√∂bbsz√∂r nyertek, de m√©g mindig valaki t√∂bbletben van, hiszen 923 egyedi link√ºnk van, teh√°t valaki m√©g
                        mindig k√©tszer jelenik meg. Ha link szerinti duplik√°tumot keres√ºnk, az egy j√≥ megk√∂zel√≠t√©s, hiszen √≠gy
                        kider√ºl, hogy az egyik szem√©ly mivel k√©t f√©le k√©ppen √≠rt√°k a nev√©t, egyszer r√∂vid√≠tve a k√∂z√©ps≈ët, m√°skor
                        teljesen ki√≠rva eddig nem kaptuk el:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df_dupes_by_link = df[df.duplicated('link', keep=False)]
print(df_dupes_by_link)

""" output:
                                                  link                  name  year   category  ...     date_of_death     place_of_birth place_of_death  gender
41          http://en.wikipedia.org/wiki/Linus_Pauling      Linus C. Pauling  1962      Peace  ...    18 August 1994           Portland        Big Sur    male
99          http://en.wikipedia.org/wiki/Linus_Pauling      Linus C. Pauling  1954  Chemistry  ...    18 August 1994           Portland        Big Sur    male
102          http://en.wikipedia.org/wiki/John_Bardeen          John Bardeen  1956    Physics  ...   30 January 1991            Madison         Boston    male
156          http://en.wikipedia.org/wiki/John_Bardeen          John Bardeen  1972    Physics  ...   30 January 1991            Madison         Boston    male
289  http://en.wikipedia.org/wiki/Horst_Ludwig_St%C...  Horst Ludwig St√∂rmer  1998    Physics  ...               NaN  Frankfurt am Main            NaN    male
467      http://en.wikipedia.org/wiki/Frederick_Sanger      Frederick Sanger  1958  Chemistry  ...  19 November 2013           Rendcomb      Cambridge    male
514      http://en.wikipedia.org/wiki/Frederick_Sanger      Frederick Sanger  1980  Chemistry  ...  19 November 2013           Rendcomb      Cambridge    male
955  http://en.wikipedia.org/wiki/Horst_Ludwig_St%C...      Horst L. St√∂rmer  1998    Physics  ...               NaN  Frankfurt am Main            NaN    male
958           http://en.wikipedia.org/wiki/Marie_Curie           Marie Curie  1903    Physics  ...       4 July 1934             Warsaw    Sancellemoz  female
970           http://en.wikipedia.org/wiki/Marie_Curie           Marie Curie  1911  Chemistry  ...       4 July 1934             Warsaw    Sancellemoz  female """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">√çgy annak kit√∂rl√©s√©vel eg√©sz√≠thetj√ºk m√©g ki a clean_data f√ºggv√©ny√ºket, √≠gy
                        megkapva a 923 egy√©ni Nobel-d√≠j gy≈ëztest:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># t√∂r√∂lj√ºk Horst L. St√∂rmer-t is, hiszen k√©tszer jelenik meg, k√©tf√©lek√©ppen √≠rt n√©vvel
    df = df.drop(df[(df.name == u'Horst L. St√∂rmer') & (df.year == 1998)].index)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Alapvet≈ëen, most is j√≥ az adatsorunk, megtiszt√≠tottuk a duplik√°tumokt√≥l,
                        azonban a drop_duplicates eset√©ben elk√∂vett√ºnk egy hib√°t, mely szerint nem randomiz√°ltuk el≈ësz√∂r a
                        sorokat, √≠gy mindig azon orsz√°gokat hagyta bent, amelyek alfabetikusan el≈ër√©bb j√∂nnek. A probl√©m√°t az
                        eml√≠tett randomiz√°ci√≥val fogjuk megoldani, √≠gy random maradnak bent az orsz√°gok. Teh√°t, miel≈ëtt a
                        drop_duplicates met√≥dust haszn√°ln√°nk a k√∂vetkez≈ëk√©ppen randomiz√°ljuk az adatsorunkat, felhaszn√°lva a NumPy
                        hasznos met√≥dusait a random m√≥dulb√≥l. A <em>permutation</em> t√∂k√©letes lesz ahhoz, hogy randomiz√°ljuk a
                        sorindexeket. A met√≥dus bevesz egy t√∂mbnyi √©rt√©ket (jelen esetben Pandas indxeket), √©s megkeveri ≈ëket.
                        Majd haszn√°lhatjuk a megkevert t√∂mb√∂t a DataFrame <em>reindex</em> met√≥dus√°ban, hogy be√°ll√≠tsuk az √∫j
                        indexeket:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = df.reindex(np.random.permutation(df.index))

# clean_data f√ºggv√©ny ...

# rendezz√ºk az objektumokat index√ºk szerint
df = df.sort_index()</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Kicsi vizsg√°lat ut√°n megfigyelhetj√ºk mi a k√∂vetkez≈ë tiszt√≠tand√≥ dolog az
                        adatsorunkkal kapcsolatosan:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.count())

""" output:
link              927
name              927
year              927
category          927
country           927
text              927
date_of_birth     927
date_of_death     634
place_of_birth    927
place_of_death    633 # hi√°nyz√≥ √©rt√©k
gender            927 

# minden oszlopn√°l helyben vagyunk, kiv√©tel ez al√≥l a place_of_death oszlop, aholis egy √©rt√©k hi√°nyzik
"""</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Egy kis keresg√©l√©s ut√°n meg is kaptuk azt a szem√©lyt, aki √°mb√°r nem halt meg,
                        de m√©gis bevan jegyezve n√°la egy elhal√°loz√°si d√°tum, ami √©rdekes m√≥don 2009, mik√∂zben 2017 Nobel-d√≠jat
                        nyert, teh√°t att√≥l a bejegyz√©st≈ël mindenk√©pp megkell v√°lnunk:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df[(df.place_of_death.isnull()) & (~(df.date_of_death.isnull()))])

df.loc[(df.name == 'Richard Henderson') & (df.year == 2017), 'date_of_death'] = np.nan;</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal pb-3">Teh√°t, alapvet≈ëen a jelen √°ll√°sban egy el√©gg√© teljes adatsorral
                        rendelkez√ºnk. A tov√°bbiakban, v√©gs≈ë sim√≠t√°sokat v√©gz√ºnk az √°ltal, hogy foglalkozunk az id≈ëbeli mez≈ëkkel.
                    </p>
                    <p class="text-lg font-normal pb-3">Jelenleg a d√°tum mez≈ëk, legyen az date_of_birth, vagy a date_of_death
                        stringekk√©nt vannak reprezent√°lva. M√©g nem tal√°lkoztunk elt√©r≈ë form√°tumokkal, de megt√∂rt√©nhet az is, hogy
                        az adatsorunkban, mivel ember √°ltal √≠rt adatokr√≥l van sz√≥, elt√©r≈ë form√°tumban vannak a d√°tumok, amely √≠gy
                        √©rtelmez√©skor gondot okozhat. A k√©s≈ëbbiekben ak√°r m≈±veleteket szeretn√©nk v√©gezni a d√°tumokkal, p√©ldak√©ppen
                        k√©t d√°tumot kivonni egym√°sb√≥l az√©rt, hogy megkapjuk a nyer√©skori √©letkort, ez√©rt egy olyan form√°tumba kell
                        alak√≠tani d√°tumjaikat, amely lehet≈ëv√© teszi ezt.
                    </p>
                    <p class="text-lg font-normal">Csod√°latos dolog az, hogy a Pandas rendk√≠v√ºl j√≥l dolgozik √©s √©rtelmezi a
                        k√ºl√∂nb√∂z≈ë d√°tumokat √©s id≈ëpontokat, k√∂nnyen √°talak√≠tja a NumPy datetime64 objektum√°v√°, alap√©rtelmezetten.
                        V√©g√ºl, ezen objektum rendelkezik sz√°munkra hasznos met√≥dusokkal √©s overloadolt oper√°torokkal. Ahhoz, hogy
                        √°talak√≠tsuk az id≈ëoszlopokat datetime64-√© haszn√°ljuk a Pandas <em>to_datetime</em> met√≥dus√°t:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># alap√©rtelmezetten az errors param√©ter ignore-dra van √°ll√≠tva, jelen esetben azt akarjuk, hogy ezeket mutassa ki
print(pd.to_datetime(df.date_of_birth, errors='raise'))

""" output:
1      1946-10-20
2      1940-10-15
3      1944-01-06
6      1887-02-05
7      1929-01-30
          ...
1131   1931-11-26
1132   1906-09-06
1133   1887-04-10
1134   1878-11-01
1135   1967-02-24 """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">A fenti esetben az√©rt akarjuk megjelen√≠teni a hib√°kat, mert tudni akarjuk azt,
                        hogy futott-e valamilyen gondba a d√°tumok √©rtelmez√©sekor a Pandas, jelen esetben szerencs√©nkre nem t√∂rt√©nt
                        ilyen. Ha alapvet≈ëen, valamilyen probl√©m√°ba √ºtk√∂zt√ºnk volna az elemz√©s sor√°n, a legszofisztik√°ltabb
                        megold√°s a to_datetime <em>coerce</em> argumentuma lenne, hiszen azt be√°ll√≠tva b√°rmilyen kiv√©telt, amit
                        nem tudott elemezni a f√ºggv√©ny NaT-nak (not a time) √°ll√≠t be, majd azokat ahol ez √≠gy t√∂rt√©nt megkeresve,
                        jav√≠thatjuk ≈ëket vagy ak√°r √≠gy is hagyhatjuk. Teh√°t, alak√≠tsuk √°t a to_datetime-al az oszlop√©rt√©keinket:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># √°talak√≠tjuk datetime64 objektumm√° az id≈ëoszlopainkat
df.date_of_birth = pd.to_datetime(df.date_of_birth, errors='coerce')
df.date_of_death = pd.to_datetime(df.date_of_death, errors='coerce')</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Mostm√°r, hogy az id≈ëoszlopainkkal egy haszn√°lhat√≥ form√°ban rendelkez√ºnk, adjunk
                        hozz√° egy olyan √∫j mez≈ët a DateFrame-√ºnkh√∂z, amely tartalmazza azt az √©letkort, ah√°ny √©ves volt a
                        Nobel-gy≈ëztes, amikor megkapta az elismer√©st. Ahhoz, hogy megkapjuk az √∫j d√°tumjaink √©v √©rt√©k√©t, megkell
                        mondanunk a Pandas-nak, hogy egy d√°tum oszloppal dolgozik, erre a <em>DateTimeIndex</em> met√≥dust
                        haszn√°ljuk a k√∂vetkez≈ëk√©ppen:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># kisz√°moljuk minden gy≈ëztes eset√©n az √©letkorukat, amikor megkapt√°k a d√≠jat,
# haszn√°ljuk a DateTimeIndex met√≥dust, hogy jelezz√ºk a Pandas-nak d√°tummal dolgozunk
df['award_age'] = df.year - pd.DatetimeIndex(df.date_of_birth).year</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Haszn√°lhatjuk ezt az √∫j oszlopot arra, hogy √©rdekess√©gk√©ppen megvizsg√°ljuk kik
                        voltak a legfiatalabbak, amikor megkapt√°k a Nobel-d√≠jat:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.sort_values('award_age').iloc[:10][['name', 'award_age', 'category', 'year']])

""" output:
                        name  award_age                category  year
702         Malala Yousafzai         17                   Peace  2014
1017  William Lawrence Bragg         25                 Physics  1915
754              Nadia Murad         25                   Peace  2018
521     Georges J. F. K√∂hler         30  Physiology or Medicine  1976
131            Tsung-Dao Lee         31                 Physics  1957
443               Paul Dirac         31                 Physics  1933
885   Werner Karl Heisenberg         31                 Physics  1932
86             Carl Anderson         31                 Physics  1936
905         Rudolf M√∂ssbauer         32                 Physics  1961
49           Tawakkol Karman         32                   Peace  2011 """</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Jelenleg, a mostani tud√°sunk alapj√°n egy tiszta adatsorral rendelkez√ºnk,
                        azonban term√©szetesen az adat-felfedez≈ës r√©szben m√©g tal√°lkozhatunk egy√©b hib√°kkal is, amit korrig√°lnunk
                        kell. De, mostm√°r √∂ssze√°ll√≠thatjuk a v√©gleges clean_data f√ºggv√©ny√ºnket:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">def clean_data(df):
    # els≈ë l√©p√©sben, az √∂sszes √ºres √©rt√©ket NaN-ra √°ll√≠tjuk, hogy a Pandas a statisztik√°k sor√°n nem sz√°molja
    df = df.replace("", np.nan)
    # kieg√©sz√≠t≈ë l√©p√©sekben t√∂r√∂lj√ºk a csillagokat √©s a felesleges space-t a nevekb≈ël
    df.name = df.name.str.replace("*", "")
    df.name = df.name.str.strip()

    # l√©trehoz egy √∫j DataFrame-t azokkal a sorokkal, ahol valid born_in mez≈ë van
    df_born_in = df[df.born_in.notnull()]
    # m√°sodik l√©p√©sben, az √∂sszes olyan sort t√∂r√∂lj√ºk a DataFrame-b≈ël, amelyn√©l a born_in nem volt √ºres, azaz nem volt NaN
    df = df[df.born_in.isnull()]

    # harmadik l√©p√©sben, t√∂r√∂lj√ºk a born_in oszlopot, hiszen nem relev√°ns, nincs egy olyan sor sem, amely √©rt√©ket t√°rolna ott
    df = df.drop("born_in", axis=1)
    df = df.reindex(np.random.permutation(df.index))

    # negyedik l√©p√©sben t√∂r√∂lj√ºk a duplik√°tumokat, k√©t relev√°ns szempont szerint, ami els≈ëk√©nt a n√©v, majd az √©v,
    # azokat t√∂rli, ahol mindkett≈ë megegyezik, √≠gy elker√ºlve azt, hogy olyant t√∂r√∂lj√ºnk aki k√©tszert nyert
    df = df.drop_duplicates(['name', 'year'])

    # t√∂r√∂lj√ºk a duplik√°tum lengyel karakteres Curie-t
    # rendezz√ºk az objektumokat index√ºk szerint
    df = df.sort_index()

    df = df.drop(df[(df.name == u'Marie Sk\u0142odowska-Curie')].index)
    # t√∂r√∂lj√ºk a rossz d√°tummal fel√≠rt Ragnar Granit-ot is
    df = df.drop(df[(df.name == 'Ragnar Granit') & (df.year == 1809)].index)
    # jav√≠tjuk az elhib√°zott 1809-es d√°tumokat
    df.loc[(df.name == 'Artturi Ilmari Virtanen') & (df.year == 1809), 'year'] = 1945
    df.loc[(df.name == u'Frans Eemil Sillanp\u00E4\u00E4') & (df.year == 1809), 'year'] = 1939
    # t√∂r√∂lj√ºk Horst L. St√∂rmer-t is, hiszen k√©tszer jelenik meg, k√©tf√©lek√©ppen √≠rt n√©vvel
    df = df.drop(df[(df.name == u'Horst L. St√∂rmer') & (df.year == 1998)].index)
    # jav√≠tjuk Henderson hamis elhal√°loz√°si d√°tum√°t
    df.loc[(df.name == 'Richard Henderson') & (df.year == 2017), 'date_of_death'] = np.nan;

    # √°talak√≠tjuk datetime64 objektumm√° az id≈ëoszlopainkat
    df.date_of_birth = pd.to_datetime(df.date_of_birth, errors='coerce')
    df.date_of_death = pd.to_datetime(df.date_of_death, errors='coerce')

    # a MongoDB-n val√≥ t√°rol√°s miatt vissza kell alak√≠tani object-√© az oszlopot, √©s NaN-ra √°ll√≠tani a NaT-okat,
    # mert m√°sk√©pp nem engedi felt√∂lteni, ValueError miatt
    df.date_of_death = df.date_of_death.astype(object).where(df.date_of_death.notnull(), np.nan)

    # kisz√°moljuk minden gy≈ëztes eset√©n az √©letkorukat, amikor megkapt√°k a d√≠jat,
    # haszn√°ljuk a DateTimeIndex met√≥dust, hogy jelezz√ºk a Pandas-nak d√°tummal dolgozunk
    df['award_age'] = df.year - pd.DatetimeIndex(df.date_of_birth).year

    return df, df_born_in

df, df_born_in = clean_data(df)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                    <p class="text-lg font-normal">Nincs m√°s dolgunk, mint lementeni a m√°r megtiszt√≠tott adatsorunkat, hogy k√©s≈ëbb
                        is el√©rhet≈ë legyen, a tiszt√≠t√°s n√©lk√ºl is, felhaszn√°lva a kor√°bban l√©trehozott kieg√©sz√≠t≈ë f√ºggv√©ny√ºnket:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df, df_born_in = clean_data(df)

# felt√∂lts√ºk az adatb√°zisba
dataframe_to_mongo(df, 'nobel_prize', 'winners_cleaned', removeexisting=True, skipifexists=True)
dataframe_to_mongo(df_born_in, 'nobel_prize', 'winners_born_in', removeexisting=True, skipifexists=True)</code><button id="copy"
    class="text-sm md:text-md font-semibold">M√°sold</button></pre>
                </section>
            </section>

            <!-- negyedik r√©sze v√©ge -->

            <div class="my-8 flex content-center">
                <button class="flex-auto w-24 bg-gray-900 text-white group hover:bg-blue-800 transition duration-75 ease-in"><a
                        class="block px-4 py-2"
                        href="3.html"><span class="inline-block font-normal transform group-hover:-translate-x-1 transition
                            duration-100 ease-in">&larr;</span>
                        El≈ëz≈ë</a></button>
                <!--<button class="flex-auto w-24 ml-4 py-2 bg-gray-900 text-white group hover:bg-blue-800 transition duration-75
                    ease-in"><a class="block px-4"
                        href="#">K√∂vetkez≈ë
                        <span
                            class="inline-block font-normal transform group-hover:translate-x-1 transition duration-100 ease-in">&rarr;</span></a></button>-->
            </div>
        </main>

        <div id="arr"
            class="fixed block transition duration-100 ease-in"><a class="inline-block text-3xl py-3 px-6 hover:text-blue-800 transition duration-100 ease-in transform hover:scale-125
                opacity-50 hover:opacity-100"
                href="#menu">&uarr;</a></div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.10.2/underscore-min.js"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
        <script src="../tools/pushy-1.3.0/js/pushy.min.js"></script>
        <!-- cross-platform megold√°s a smooth-scroll-ra, jQuery haszn√°lat√°val -->
        <script src="../javascript/smooth.js"></script>
        <script src="../javascript/main.js"></script>
        <script src="../javascript/introd3.js"></script>
    </body>

</html>