<!DOCTYPE html>
<html lang="en"
    class="text-gray-800 text-base md:text-lg antialiased leading-relaxed tracking-normal break-normal bg-white">

    <head>
        <meta charset="UTF-8">
        <meta name="viewport"
            content="width=device-width, initial-scale=1.0">
        <meta name="description"
            content="A repo for studying a book.">
        <meta name="keywords"
            content="visualization,javascript,python,d3,flask,restful">
        <meta name="author"
            content="Luk√°cs Zsolt">
        <meta http-equiv="X-UA-Compatible"
            content="ie=edge">
        <title>4 Az adatok tiszt√≠t√°sa √©s feldolgoz√°sa</title>
        <link rel="stylesheet"
            href="../css/style.css">
        <!-- Safari-n az emoji favicon nem m≈±k√∂dik -->
        <link rel="icon"
            href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22
                viewBox=%220
                0
                100
                100%22><text y=%22.9em%22
                    font-size=%2290%22>üìï</text></svg>">
    </head>

    <body class="overflow-x-hidden">
        <!-- navig√°ci√≥ -->
        <nav class="pushy pushy-left">
            <div class="pushy-content">
                <ul>
                    <li class="pushy-link"><a href="../index.html">1 Bevezet√©s</a></li>
                    <li class="pushy-link"><a href="2.html">2 Els≈ë l√©p√©sek az adatvizualiz√°ci√≥ban</a></li>
                    <li class="pushy-link"><a href="3.html">3 Az adatok megszerz√©se</a></li>
                    <li class="pushy-link"><a href="4.html">4 Az adatok tiszt√≠t√°sa √©s feldolgoz√°sa</a></li>
                </ul>
            </div>
        </nav>

        <!-- Pushy-hoz site overlay -->
        <div class="site-overlay"></div>

        <main id="container"
            class="container p-8 md:p-6 max-w-2xl md:max-w-3xl min-h-screen">
            <button id="menu"
                class="menu-btn px-4 py-2 bg-gray-900 text-white hover:bg-blue-800 transition duration-75 ease-in">&#9776;
                Men√º</button>

            <!-- negyedik r√©sze eleje -->

            <section class="pb-8">
                <h1 class="text-3xl md:text-4xl py-8 text-gray-900 font-semibold">4 Az adatok tiszt√≠t√°sa √©s feldolgoz√°sa</h1>

                <section id="4numpy">
                    <h2 class="text-2xl pb-4 font-semibold text-gray-800">Bevezet√©s a NumPy-ba</h2>
                    <p id="firstPar"
                        class="text-lg font-normal pb-3">Ebben a fejezetben egy √∫jabb Python k√∂nyvt√°rral fogunk megismerkedni, a
                        Numeric Python-al, r√∂viden a NumPy-al. A NumPy kulcsfontoss√°g√∫ lesz a Pandas-al val√≥ munka sor√°n,
                        elhagyhatatlan az
                        adat-elemz√©shez haszn√°lt k√∂nyvt√°runkhoz, amellyel az ezt k√∂vet≈ë fejezetekben fogunk megismerkedni mik√∂zben
                        a
                        nemr√©g megszerzett Nobel-d√≠j adatsorunkat tiszt√≠tjuk √©s fedezz√ºk fel. Egy √°ltal√°nos ismeret √©s tud√°s a
                        NumPy alapvet≈ë elemeir≈ël n√©lk√ºl√∂zhetetlen, ha a legt√∂bbet szeretn√©nk kinyerni a Pandas-b√≥l.</p>
                    <p class="text-lg font-normal pb-3">A NumPy egy Python m√≥dul, amely el√©rhet≈ëv√© tesz nagyon gyors,
                        t√∂bb-dimenzi√≥s t√∂mb manipul√°l√°st, mindezt a h√°tt√©rben alacsony szint≈± k√∂nyvt√°rakkal megt√°mogatva C-ben √©s
                        Fortran-ban √≠rva. A Python nat√≠v teljes√≠tm√©nye nagy mennyis√©g≈± adattal lass√∫, nagyon magas nyelv l√©v√©n, de
                        a NumPy lehet≈ëv√© tesz azt, hogy p√°rhuzamosan hajts v√©gre m≈±veleteket nagy t√∂mb√∂k√∂n egyidej≈±leg, ez √°ltal
                        nagyon gyorss√° t√©ve.</p>
                    <p class="text-lg font-normal pb-3">Mondhatni, a NumPy minden adat-feldolgoz√°si munk√°nak az alapj√°t k√©pzi, de
                        tov√°bb√° elmondhat√≥ az is, hogy maga a NumPy √∂kosziszt√©ma is rendk√≠v√ºl kiterjedt, olyan kieg√©sz√≠t≈ëkkel
                        rendelkezik, mint a SciPy, a Python tudom√°nyos m√≥dulja, amely bonyolult tudom√°nyos √©s m√©rn√∂ki m√≥dulokat
                        tartalmaz. De megeml√≠thet≈ë m√©g a Scikit-learn, amely rendelkez√©s√ºnkre bocs√°jt machine-learning
                        algoritmusokat. Azonban, az eml√≠tetteken k√≠v√ºl m√©g sz√°mos kieg√©sz√≠t≈ëvel rendelkezik a NumPy √©s szakosodott
                        k√∂nyvt√°rak is l√©teznek, amelyek a NumPy t√∂bb-dimenzi√≥s t√∂mbjeire √©p√ºlnek.</p>
                    <p class="text-lg font-normal pb-3">Amit legf≈ëk√©ppen megkell teh√°t √©rteni a NumPy-al kapcsolatosan, az nem
                        m√°s, mint a t√∂mbjei, a k√∂vetkez≈ëkben p√©ld√°kon kereszt√ºl azokat fogjuk megvizsg√°lni.</p>
                    <p class="text-lg font-normal">A NumPy-ban minden a t√∂bb-dimenzi√≥s <em>ndarray</em> objektumra √©p√ºl. Egy√©b
                        dolgok mellett, olyan egyszer≈±eket is ellehet v√©gezni ezen objektumokon, mint az aritmetikai m≈±veletek,
                        ahogy azt elemi t√≠pusok, ak√°r floatok eset√©ben is tenn√©nk. N√©zz√ºk meg ezt egy p√©ld√°n kereszt√ºl:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">import numpy as np

a = np.array([1, 2, 3])

a + a # output: array([2, 4, 6])</code></pre>
                    <p class="text-lg font-normal">Az ndarray objektum h√°rom fontos tulajdons√°ggal rendelkezik, a dimenzi√≥k sz√°ma
                        <em>(ndim)</em>, az alakja <em>(shape)</em>, v√©g√ºl a numerikus t√≠pusa <em>(numeric type)</em>. Ugyanaz a
                        t√∂mbnyi sz√°m ak√°r √°talak√≠that√≥ helyben is, amely ak√°r mag√°ba foglalhatja a t√∂mb dimenzi√≥inak sz√°m√°nak
                        megv√°ltoz√°s√°t is. A k√∂vetkez≈ë p√©lda egy ilyent helyzetet szeml√©ltet:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># ezt a f√ºggv√©nyt fogjuk haszn√°lni a 3 tulajdons√°g ki√≠r√°s√°ra
def print_array_details(a):
    print('Dimensions: {}, shape: {}, dtype: {}'.format(a.ndim, a.shape, a.dtype))

a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
print(a)
print_array_details(a)
# output:
# [1 2 3 4 5 6 7 8 9]
# Dimensions: 1, shape: (9,), dtype: int32</code></pre>
                    <p class="text-lg font-normal">Felhaszn√°lva a <em>reshape</em> met√≥dust, k√©pesek vagyunk megv√°ltoztatni az
                        alakj√°t √©s a dimenzi√≥inak sz√°m√°t az 'a' t√∂mbnek. Alak√≠tsuk √°t a jelenlegi t√∂mb√ºnket egy 3 dimenzi√≥s
                        t√∂mbb√©, amely 3 darab 3 tagb√≥l √°ll√≥ t√∂mbb≈ël √°ll:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">a = a.reshape([3, 3])
print(a)
print_array_details(a)
# [[1 2 3]
#  [4 5 6]
#  [7 8 9]]
# Dimensions: 2, shape: (3, 3), dtype: int32</code></pre>
                    <p class="text-lg font-normal">A k√∂vetkez≈ë p√©ld√°ban egy √∂sszesen 8 tagb√≥l √°ll√≥ t√∂mb h√°rom dimenzioss√° is
                        tehet≈ë:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">b = np.array([1, 2, 3, 4, 5, 6, 7, 8])
b = b.reshape([2, 2, 2])
print(b)
print_array_details(b)
# [[[1 2]
#   [3 4]]
# 
#  [[5 6]
#   [7 8]]]
# Dimensions: 3, shape: (2, 2, 2), dtype: int32</code></pre>
                    <p class="text-lg font-normal pb-3">A fenti p√©ld√°kb√≥l m√°r √°ltal√°noss√°gban kik√∂vetkeztethet≈ë n√©h√°ny dolog.
                        Egyr√©szt,
                        a dimenzi√≥k sz√°m√°t az alakja hat√°rozza meg, illetve ahhoz, hogy egy bizonyos dimenzi√≥t bet√∂lts√∂n egy
                        t√∂mbnyi sz√°m, minimum <em>n^ndim</em> elemmel kell rendelkezzen, (n, n, n) alak eset√©n.</p>
                    <p class="text-lg font-normal">A t√∂mb alakja √©s numerikus t√≠pusa l√©trehoz√°skor is meghat√°rozhat√≥, ugyanakkor
                        l√©trehoz√°s ut√°n a legk√∂nnyebb megold√°s a t√∂mb numerikus t√≠pus√°nak megv√°ltoztat√°s√°ra a reshape-hez
                        hasonl√≥an
                        az <em>astype</em> met√≥dus lenne. Eben az esetben a met√≥dus egy √°tm√©retezett m√°solatot k√©sz√≠t az eredeti
                        t√∂mbr≈ël a mod√≥s√≠tott t√≠pussal:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">x = np.array([[1, 2, 3], [4, 5, 6]], np.int64)
print(x.shape) # output: (2, 3)
print(x.dtype) # output: int64

x.shape = (6, )
x = x.astype('int32')
print(x.shape) # output: (6, )
print(x.dtype) # output: int32</code></pre>
                    <p class="text-lg font-normal">Amellett, hogy NumPy eset√©n lehet≈ës√©g√ºnk van sz√°msorokb√≥l t√∂mb√∂ket l√©trehozni,
                        biztos√≠t j√≥n√©h√°ny kieg√©sz√≠t≈ë f√ºggv√©nyt, hogy l√©trehozzunk t√∂mb√∂t egy bizonyos mint√°val. <em>zeros</em> √©s
                        <em>ones</em> f√ºggv√©nyek p√©ldak√©ppen a leggyakrabban haszn√°ltak k√∂z√© tartoznak, amelyek el≈ëre felt√∂lt√∂tt
                        t√∂mb√∂ket hoznak l√©tre a megadott mint√°val. Fontos megjegyezni, hogy ezek a f√ºggv√©nyek √°ltal√°ban float64
                        t√≠pussal dolgoznak, √©s nem intekkel:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">a = np.zeros([2, 3])
print(a)
print(a.dtype)
# output:
# [[0. 0. 0.]
#  [0. 0. 0.]]
# float64

b = np.ones([2, 3])
print(b)
print(b.dtype)
# output:
# [[1. 1. 1.]
#  [1. 1. 1.]]
# float64</code></pre>
                    <p class="text-lg font-normal">Emellett, rendelkez√©s√ºnkre √°ll egy <em>empty</em> met√≥dus is, amely l√©trehozza
                        a sz√ºks√©ges mem√≥ria-blokkot, azonban nem t√∂lti fel azt elemekkel √©s az inicializ√°l√°st r√°nk hagyja:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">empty_arr = np.empty([2, 3])
print(empty_arr)
# output: 
# [[1. 1. 1.]
#  [1. 1. 1.]]
# az output v√°ltozhat, att√≥l f√ºgg≈ëen √©ppen mi volt a mem√≥riater√ºleten</code></pre>
                    <p class="text-lg font-normal">A k√∂vetkez≈ë hasznos met√≥dus a <em>random</em>, amely a random m√≥dulon bel√ºl
                        tal√°lhat√≥ meg egy√©b hasznos f√ºggv√©nyekkel egy√ºtt. Ez l√©trehoz egy megadott mint√°j√∫ random sz√°mokkal
                        felt√∂lt√∂tt t√∂mb√∂t:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">rand_arr = np.random.random([2, 3])
print(rand_arr)
# output:
# [[0.16112766 0.76956209 0.28967126]
#  [0.17799395 0.11935788 0.83240867]]</code></pre>
                    <p class="text-lg font-normal">A <em>linspace</em> l√©trehoz egy meghat√°rozott sz√°m≈± elemb≈ël √°ll√≥ egyenl≈ë
                        eloszl√°s√∫ t√∂mb√∂t, egy megadott intervalumon bel√ºl, az <em>arange</em> is ehhez hasonl√≥, azonban ott
                        l√©peget√©ssel m≈±k√∂dik, teh√°t nem az elemek sz√°m√°t, hanem az elemek k√∂z√∂tti √°lland√≥ k√ºl√∂nbs√©get adjuk meg:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># l√©trehozunk egy 5 elemb≈ël √°ll√≥ egyenl≈ë-eloszl√°s√∫ t√∂mb√∂t 2 √©s 10 k√∂z√∂tt
a = np.linspace(2, 10, 5)
print(a)


# l√©trehozunk egy t√∂mb√∂t 2 √©s 10 k√∂z√∂tt, kettes√©vel l√©pegetve
b = np.arange(2, 10, 2)
print(b)

# output:
# [ 2.  4.  6.  8. 10.]
# [2 4 6 8]
# az arange a fels≈ë hat√°rral kiz√°r√≥, m√≠g a linspace megenged≈ë</code></pre>
                    <p class="text-lg font-normal">A NumPy eset√©n, az egy-dimenzi√≥s t√∂mb√∂k indexel√©skor √©s slicekor ugyan√∫gy
                        viselkednek, mint a Python list√°k:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">a = np.array([1, 2, 3, 4, 5, 6, 7, 8, 9])
print(a[5])
print(a[1:3])
print(a[::-1])
a[::4] = -1
print(a)

# output:
# 6
# [2 3]
# [9 8 7 6 5 4 3 2 1]
# [-1  2  3  4 -1  6  7  8 -1]</code></pre>
                    <p class="text-lg font-normal pb-3">A t√∂bb-dimenzi√≥s t√∂mb√∂k indexel√©se nagyban hasonl√≠t az egy-dimenzi√≥s
                        t√∂mb√∂k√©hez. Minden dimenzi√≥nak megvan a maga index √©s slice m≈±velete, √©s ezeket vessz≈ëvel elv√°lasztott
                        tuple-k√©nt hat√°rozzuk meg. A k√∂vetkez≈ë √°bra szeml√©lteti a folyamatot:
                    </p>
                    <figure>
                        <img class="mx-auto"
                            src="../img/fig14.png"
                            alt="√Åbra 14">
                        <figcaption class="text-center pt-3 pb-4 text-md">14. √Åbra: A t√∂bb-dimenzi√≥s indexel√©s NumPy-al
                        </figcaption>
                    </figure>
                    <p class="text-lg font-normal">Abban az esetben, ha az objektumok sz√°ma a tuple-ben kevesebb, mint a dimenzi√≥k
                        sz√°ma, abban az esetben, azt felt√©telezi, hogy a teljes eg√©sz√©t kiv√°lasztottuk a hi√°nyz√≥nak, de ak√°r
                        ellipsziseket is haszn√°lhatunk a teljes kiv√°laszt√°sra:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">a = np.arange(16, dtype='int64')
a = a.reshape([2, 2, 4])
# print(a)
# print(a[0, 1])
print(a[0, :, 2:3])
print(a[0, :, :])
print(a[0, ...])

# output:
# [[2]
#  [6]]
# [[0 1 2 3]
#  [4 5 6 7]]
# [[0 1 2 3]
#  [4 5 6 7]]</code></pre>
                    <p class="text-lg font-normal">Az egyik legjobb dolog a NumPy t√∂mb√∂kkel kapcsolatosan, hogy k√©pes vagy
                        alapvet≈ë √©s nem is annyira alapvet≈ë m≈±veleteket elv√©gezni vel√ºk, olyan m√≥don ahogy azt kor√°bban is
                        megszokhattad, teh√°t mint sima numerikus v√°ltoz√≥kkal. Az egyszer≈± matematikai m≈±veletek, ahogy azt
                        elv√°rn√°nk minden t√∂mbelemen v√©grehajt√°sra ker√ºlnek:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">a = np.arange(1, 7, dtype='int64')
print(a)
a = a.reshape([2, 3])
print(a)
print(a + 2)
print(a * 2)
print(a / 2.0)
# a fenti oszt√°s eset√©ben, implicit m√≥don, amikor float sz√°mmal osztunk, a t√∂mb √°talak√≠t√°sra ker√ºl float64 t√≠pus√∫v√°

# output:
# [1 2 3 4 5 6]
# [[1 2 3]
#  [4 5 6]]
# [[3 4 5]
#  [6 7 8]]
# [[ 2  4  6]
#  [ 8 10 12]]
# [[0.5 1.  1.5]
#  [2.  2.5 3. ]]</code></pre>
                    <p class="text-lg font-normal">A logikai oper√°torok hasonl√≥ logika ment√©n m≈±k√∂dnek, ahogy azt a k√∂vetkez≈ë
                        p√©lda is szeml√©lteti:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(a &#60; 4)
# output:
# [[ True  True  True]
# [False False False]]</code></pre>
                    <p class="text-lg font-normal">A t√∂mb√∂k emellett hasznos met√≥dusokkal is rendelkeznek, a m≈±veleteken t√∫l,
                        amelyeket a k√∂vetkez≈ë p√©lda is szeml√©ltet:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">a = np.arange(10).reshape([2, 5])

print(a.min(axis=1))
# output: [0 5]

print(a.sum(axis=0))
# output: [ 5  7  9 11 13]

print(a.sum(axis=1))
# output: [10 35]

print(a.mean(axis=1))
# output: [2. 7.]

# sz√≥r√°s
print(a.std(axis=1))
# output: [1.41421356 1.41421356]

# az axis = 0 eset√©n, f√ºgg√∂legesen, a dimenzi√≥k k√∂z√∂tt, √∂sszegzi (pl.) az elemeket 
# az axis = 1 eset√©n, v√≠zszintesen, a dimenzi√≥kon bel√ºl, √∂sszegzi az elemeket</code></pre>
                    <p class="text-lg font-normal">Tov√°bb√°, nagysz√°m√∫ be√©p√≠tett t√∂mb f√ºggv√©nnyel is rendelkezik a NumPy,
                        megintcsak az al√°bbi p√©lda szeml√©ltet ezek k√∂z√ºl n√©h√°nyat:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">pi = np.pi
a = np.array([pi, pi/2, pi/4, pi/6])
print(np.degrees(a)) # √°talak√≠tja radi√°nb√≥l fokba a megadott t√∂mb elemeit
# output: [180.  90.  45.  30.]

sin_a = np.sin(a) # visszat√©r√≠ti a radi√°nok szinusz √©rt√©k√©t
print(sin_a)
# output: [1.22464680e-16 1.00000000e+00 7.07106781e-01 5.00000000e-01]

print(np.round(sin_a, 7)) # kerek√≠ti 7 tizedespontos√°ggal
# output: [0.        1.        0.7071068 0.5      ]

a = np.arange(8).reshape([2, 4])

print(np.cumsum(a, axis=1))
# halmozott √∂sszeg a m√°sodik tengely ment√©n, teh√°t jelenesetben v√≠zszintesen, dimenzi√≥kon bel√ºl

print(np.cumsum(a))
# a tengelymeghat√°roz√°s n√©lk√ºl a t√∂mb kisimul, teh√°t egy-dimenzi√≥ss√° alakul

# output:
# [[ 0  1  3  6]
#  [ 4  9 15 22]]
# [ 0  1  3  6 10 15 21 28]</code></pre>
                    <p class="text-lg font-normal pb-3">F√ºggetlen√ºl att√≥l, hogy melyik Python adat-feldolgoz√°si k√∂nyvt√°rat
                        haszn√°lod,
                        legyen az Pandas, Scipy, vagy scikit-learn, esetleg PyBrain, nagy es√©ly van r√°, hogy az alapvet≈ë m√∂g√∂ttes
                        adat-strukt√∫ra a NumPy t√∂mbje lesz.
                    </p>
                    <p class="text-lg font-normal pb-3">Ilyen √©rtelemben, a k√©pess√©g arra, hogy l√©trehozhassunk t√∂mb feldolgoz√°si
                        f√ºggv√©nyeket nagy seg√≠ts√©g√ºnkre lehet a tov√°bbiakban.
                    </p>
                    <p class="text-lg font-normal pb-3">A k√∂vetkez≈ëkben ezzel ismerked√ºnk meg mik√∂zben megpr√≥b√°ljuk megszel√≠diteni
                        a t√∂mb√∂ket, hogy kisz√°molhassunk egy statisztikai mozg√≥√°tlagot. Nagyon egyszer≈±en elmondva a mozg√≥√°tlag
                        egy olyan statisztikai sz√°m√≠t√°s, amely sor√°n az √°ltal elemezz√ºk az adatpontokat, hogy a nagy adatsort
                        kisebb adatsorokra bontjuk √©s azok √°tlagait √°tlagoljuk.
                    </p>
                    <p class="text-lg font-normal pb-3">A k√∂vetkez≈ëkben ezzel ismerked√ºnk meg mik√∂zben megpr√≥b√°ljuk megszel√≠diteni
                        a t√∂mb√∂ket, hogy kisz√°molhassunk egy statisztikai mozg√≥√°tlagot. Nagyon egyszer≈±en elmondva a mozg√≥√°tlag
                        egy olyan statisztikai sz√°m√≠t√°s, amely sor√°n l√©nyeg√©ben √°tlagok sorozat√°t sz√°moljuk egy mozg√≥ "ablakon"
                        (adatsoron) bel√ºl a legutols√≥ n darab √©rt√©kb≈ël, ahol az n egy v√°ltoz√≥ sz√°m.
                    </p>
                    <p class="text-lg font-normal">Egy-dimenzi√≥s t√∂mb eset√©ben n√©h√°ny sor alatt ki lehet sz√°molni a mozg√≥√°tlagot:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">def moving_average(a, n=3):
    ret = np.cumsum(a, dtype=float)
    ret[n:] = ret[n:] - ret[:-n]
    return ret[n - 1:] / n</code></pre>
                    <p class="text-lg font-normal pb-3">Teh√°t, a f√ºggv√©ny bevesz egy a t√∂mb√∂t, √©s egy n sz√°mot, amely meghat√°rozza
                        a
                        mozg√≥ ablakunk hossz√°t, jelen esetben alap√©rtelmezetten ez egyenl≈ë 3-al. Els≈ë l√©p√©sben, halmozott √∂sszeget
                        sz√°molunk a NumPy be√©p√≠tett f√ºggv√©ny√©vel. A halmozott √∂sszeg, mint tudjuk, l√©nyeg√©ben a t√∂mb elemein
                        v√©gighaladva, az √∂sszes addigi elem √∂sszege, bele√©rtve az aktu√°list is.
                    </p>
                    <p class="text-lg font-normal">M√°sodik l√©p√©sben, kezdve a halmozott √∂sszeg n-edik index√©t≈ël, kivonjuk az
                        i-n-edik √©rt√©k√©t minden i-b≈ël, ami azt jelenti, hogy az i most minden √©rt√©k √∂sszege az utols√≥ n elemnek,
                        bele√©rtve az n-ediket is, valahogy √≠gy:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="plaintext">[ 0, 1, 2, 3, 4, 5] t√∂mb eset√©n, el≈ësz√∂ris halmozott √∂sszeget sz√°molunk, √≠gy megkapjuk
a [0, 1, 3, 6, 10, 15] t√∂mb√∂t, k√∂vetkez≈ë l√©p√©sben elkezdj√ºk az n-edik indext≈ël, √©s kivonjuk bel≈ële az i-n-edik indexet,
√≠gy a t√∂mb a [0, 1, 3, 6-0, 10-1, 15-3] t√∂mb√∂t,
mivel 3 elemb≈ël √°ll√≥ subseteink vannak, 3-1-t≈ël van √©rtelme √°tlagot sz√°molni, √≠gy a visszat√©r√≠tett √°tlagjaink a
[3 / 3, 6 / 3, 9 / 3, 12 / 3] lesznek.</code></pre>
                    <p class="text-lg font-normal">Ak√°r pap√≠r mellett √©l≈ëben is megvizsg√°lhatjuk a f√ºggv√©ny√ºk helyes m≈±k√∂d√©s√©t:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(moving_average(np.arange(6)))
# output: [1. 2. 3. 4.]</code></pre>
                </section>

                <section id="4pandas">
                    <h2 class="text-2xl pt-8 pb-4 font-semibold text-gray-800">Bevezet√©s a Pandas-ba</h2>
                    <p class="text-lg font-normal pb-3">A Pandas az egyik legfontosabb eleme az adat-vizualiz√°ci√≥s
                        eszk√∂zt√°runknak, hiszen ezt a k√∂nyvt√°rat fogjuk haszn√°lni a kor√°bban megszerzett adat√∂sszes√©g√ºnk
                        tiszt√≠t√°s√°ra √©s felfedez√©s√©re, valamint elemz√©s√©re. Alapvet≈ëen, b√°rmilyen adat-vizualiz√°ci√≥t vesz√ºnk a
                        netr≈ël, vagy ak√°r pap√≠r form√°ban, nagy az es√©ly r√°, hogy a megjelen√≠tett adat, kor√°bban valamilyen
                        t√°bl√°zatos form√°ban ker√ºlt t√°rol√°sra, legyen az Excel vagy egyszer≈± CSV √°llom√°ny. A Pandas pont a
                        t√°bl√°zatos form√°ban t√°rolt adatok feldolgoz√°s√°ra ker√ºlt testreszab√°sra, hiszen az alapvet≈ë adatt√≠pusa a
                        DataFrame, amelyet legjobban egy nagyon gyors spreadsheetk√©nt lehet felfogni.</p>
                    <p class="text-lg font-normal pb-3">Alapvet≈ëen, a Pandas-t arra tervezt√©k, hogy heterog√©n adatokkal dolgozzon,
                        amelyek a t√°bl√°zatos form√°ban megjelen√≠tett spreadsheetekben is tal√°lhat√≥k, azonban nagyon j√≥l kitudja
                        haszn√°lni m√©g ekkor is a NumPy gyorsas√°g√°t, amelyet pedig homog√©n numerikus t√∂mb√∂k rendez√©s√©re
                        sz√°nd√©koltak, matematikusok, fizikusok, stb. seg√≠ts√©g√©re.</p>
                    <p class="text-lg font-normal pb-3">Miel≈ëtt nekifogn√°nk, hogy megismerkedj√ºnk a Pandas-al, els≈ëk√©nt annak
                        DataFrame t√≠pus√°val, √©s azzal, hogy hogyan lehet az adatunkat √°thelyezni DataFrame-b≈ël a gyakori
                        adatt√°rol√°si lehet≈ës√©geinkb≈ël, ak√°r f√°jlokb√≥l, ak√°r adatb√°zisokb√≥l, el≈ësz√∂ris megkell √©rten√ºnk azt, hogy
                        mit is √©rt√ºnk a heterog√©n adatsorok, adatok alatt, amelyekre tervezt√©k a Pandas-t.</p>
                    <p class="text-lg font-normal pb-3">Ha egy vizualiz√°ci√≥t n√©z√ºnk, legyen az b√°rmilyen form√°ban, ak√°r egy
                        oszlopdiagram vagy vonaldiagram, amelyet egy cikk vagy valamilyen dashboard illusztr√°l√°s√°ra k√©sz√≠tettek
                        el, nagy es√©ly van r√°, hogy egy val√≥di m√©r√©s eredm√©ny√©t √°br√°zolja √©s mutatja be, p√©ldak√©ppen az egy √©v
                        alatti csapad√©kv√°ltoz√°st, vagy ak√°r etnikai csoportok szerinti szavaz√°si hajland√≥s√°g, stb, a lehet≈ës√©gek
                        l√©nyeg√©ben v√©gtelenek. Nam√°rmost, ezek a m√©r√©sek sz√©les √©rtelemben v√©ve k√©t csoportba oszthat√≥k
                        <em>numerikus</em> √©s <em>kategorikus</em> m√©r√©sek.</p>
                    <p class="text-lg font-normal pb-3">Tov√°bb√°, a numerikus √©rt√©kek megintcsak k√©t kateg√≥ri√°ba oszthatok, vannak
                        <em>intervallum</em> numerikus adatok √©s <em>ar√°nysz√°mok</em>. A kategorikus √©rt√©kek k√©t t√≠pusa pedig a
                        <em>nomin√°lis</em>
                        √©s
                        <em>ordin√°lis</em> m√©r√©sek.</p>
                    <p class="text-lg font-normal">P√©ldak√©ppen, vegy√ºk a k√∂vetkez≈ë esetet, a p√©lda nem, m√°st mint egy tweet, az
                        azt tartalmaz√≥ egy√©b adatmez≈ëkkel:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">{
"text": "#Python and #JavaScript sitting in a tree...",
"id": 2103303030333004303,
"favorited": true,
"filter_level":"medium",
"created_at": "Wed Mar 23 14:07:43 +0000 2015",
"retweet_count":23,
"coordinates":[-97.5, 45.3]
...
}</code></pre>
                    <p class="text-lg font-normal pb-3">A p√©ld√°t v√©ve, elmondhat√≥, hogy a 'text' √©s 'id' mez≈ëk egyedi azonos√≠t√≥k,
                        az
                        els≈ë ak√°r tartalmazhat kategorikus inform√°ci√≥t is (pl. azon tweetek kateg√≥ri√°ja, amelyek tartalmazz√°k a
                        #python hashtaget), a m√°sodik ak√°r kateg√≥ria l√©trehoz√°s√°ra is haszn√°lhat√≥ (pl. azon felhaszn√°l√≥k
                        kateg√≥ri√°ja, akik retweetelt√©k a tweetet), de ebben az √°llapotukban √©s ilyen form√°ban ezek nem
                        vizualiz√°lhat√≥k. Azt√°n, a 'favorited' mez≈ë a fenti sz√°mokkal √©s stringekkel ellent√©tben boolean √©rt√©k, √≠gy
                        kategorikus inform√°ci√≥, hiszen a tweeteket k√©t csoportba osztja. A kategorikus m√©r√©sen bel√ºl a 'favorited'
                        mez≈ë nomin√°lisnak sz√°m√≠t, hiszen meglehet sz√°molni, de nem lehet sorbarendezni.</p>
                    <p class="text-lg font-normal pb-3">A 'filter_level' ugyancsak kategorikus m√©r√©s, azonban ez m√°r ordin√°lis,
                        hiszen
                        k√©pesek vagyunk egy sorrendet fel√°ll√≠tani. A 'created_at' m√°r numerikus m√©r√©s, azon bel√ºl intervallum, √©s
                        vizualiz√°ci√≥kor p√©ld√°ul ezen sk√°la ment√©n szeretn√©nk rendezni a tweeteket, id≈ërendi sorrendben, ak√°r
                        napokra √©s hetekre lebontva, ezt a folyamatot nagyban megk√∂nny√≠ti a Pandas, s≈ët, a rendez√©st automatikusan
                        v√©gzi el. A 'retweet_count' szint√©n numerikus adat, de ebben az esetben egy ar√°nysz√°m/ar√°ny-sk√°la. Az
                        ar√°nysk√°l√°nak az a nagyon fontos tulajdons√°ga, hogy van egy jelent≈ës√©gteljes z√©r√≥ √©rt√©ke, ebben az esetben
                        ez a retweet hi√°ny√°t jelenti, az el≈ëz≈ë 'created_at' adatunk eset√©n tetsz≈ëleges √©rt√©keket vehet fel, √©s
                        tetsz≈ëleges alap√°llapota/alapvonala, kiindul√°si pontja lehet.</p>
                    <p class="text-lg font-normal pb-3">A 'coordinates' mez≈ë m√°r k√©t numerikus sk√°l√°val rendelkezik, egy
                        hossz√∫s√°gi
                        koordin√°t√°val, √©s egy sz√©less√©givel. Hi√°ba mondhat√≥ el a hossz√∫s√°gir√≥l, hogy √∂nk√©nyesen ker√ºlt
                        kiv√°laszt√°sra, jelenesetben a Greenwich-i d√©lk√∂rt≈ël sz√°molva, a sz√©less√©gi k√∂r pedig az egyenl√≠t≈ët≈ël van,
                        ebben az esetben m√°r szab√°lyszer≈±en, hiszen a F√∂ld p√≥lusai hat√°rozz√°k meg, mindkett≈ë intervallum, hiszen
                        nem sok √©rtelme van fokok eset√©ben ar√°nysz√°mnak tekinteni ≈ëket.</p>
                    <p class="text-lg font-normal pb-3">Teh√°t, a fenti p√©ld√°nk r√°mutat arra, hogyan is lehet elk√©pzelni a
                        heterog√©n
                        adatokat, lefedve a leggyakoribb √©s legelfogadtabb m√©r√©si t√≠pusokat. Ugyanakkor, a NumPy t√∂mb√∂k
                        √°ltal√°noss√°gban v√©ve homog√©n, sz√°madatok kezel√©s√©re lettek kidolgozva, a Pandas pont a fenti p√©ld√°ban
                        szeml√©ltet kategorikus adatokkal, id≈ësorokkal val√≥ munk√°ra √©s egy√©b elemek kezel√©s√©re lett kidolgozva,
                        amelyek a
                        val√≥vil√°got √©s annak heterogenit√°s√°t t≈±kr√∂zik.</p>
                    <p class="text-lg font-normal">Miut√°n, √∂sszes√©g√©ben megbesz√©lt√ºk azt, hogy milyen adatokkal dolgozik a
                        Pandas, megvizsg√°lhatjuk az elemi adatstrukt√∫r√°j√°t a DataFrame-t. A Pandas-al val√≥ munka els≈ë l√©p√©se
                        √°ltal√°ban az, hogy bet√∂lts√ºk az adatainkat egy DataFrame-be. Erre sz√°mos megk√∂zel√≠t√©s van, jelen esetben
                        megoldjuk az eg√©szet √∫gy, hogy beolvassuk a JSON adatainkat a m√°r meglev≈ë <em>nobel_winners.json</em>
                        √°llom√°nyunkb√≥l:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">import pandas as pd

# a f√ºggv√©ny visszat√©r√≠t egy DataFrame-t, elemezve a megadott JSON f√°jlt
# konvenci√≥ szerint a DataFrame v√°ltoz√≥k df-el kezd≈ëdnek
df = pd.read_json('nobel_winners.json')

print(df.head())

# output:
#     category             name nationality     sex  year
# 0    Physics  Albert Einstein       Swiss    male  1921
# 1    Physics       Paul Dirac     British    male  1933
# 2  Chemistry      Marie Curie      Polish  female  1911</code></pre>
                    <p class="text-lg font-normal">A fenti esetben m√°r haszn√°ltuk is a DataFrame <em>head</em> met√≥dus√°t, amely
                        seg√≠ts√©g√©vel alap√©rtelmezetten az els≈ë 5 sort √≠rja ki. Nam√°rmost, szeretn√©nk a kor√°bbi scrapel√©si munka
                        sor√°n megszerzett, terjedelmes, t√∂bb-soros JSON √°llom√°nyunkat √°thelyezni egy DataFrame-be. Probl√©m√°ba ott
                        √ºtk√∂ztem, mik√∂zben beakartam t√∂lteni, hogy rosszul volt form√°zva a JSON √°llom√°nyom, amikor rosszul van
                        form√°zva a k√∂vetkez≈ë error √ºzenetet √≠rja ki: <em>ValueError: Expected object or value</em> vagy
                        <em>ValueError: Trailing data</em>. A hib√°kat a JSON √°llom√°ny helyesb√≠t√©s√©vel lehet orvosolni, jelen
                        esetben a z√°r√≥jelekkel volt gond.</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')

print(df.head())

df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/minibios.json')

print(df.head())</code></pre>
                    <p class="text-lg font-normal pb-3">A fenti megjelen√≠t√©sek m√°s t≈±kr√∂zik azt, hogy a DataFrame az eml√≠tett
                        t√°bl√°zatos form√°val dolgozik, teh√°t a mez≈ëk oszlopokk√©nt √©s a mez≈ë √©rt√©kek pedig soronk√©nt m≈±k√∂dnek,
                        kieg√©sz√≠tve egy sorsz√°m oszloppal az elej√©n.</p>
                    <p class="text-lg font-normal">A DataFrame oszlopjai a columns tulajdons√°g szerint vannak indexelve, amely egy
                        Pandas index p√©ld√°ny. A k√∂vetkez≈ëk√©ppen kiv√°laszthatjuk a kor√°bbi DataFrame-jeink oszlopait:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.columns)
# output: Index(['link', 'name', 'year', 'category', 'country', 'born_in', 'text'], dtype='object')</code></pre>
                    <p class="text-lg font-normal">Alapvet≈ëen, Pandas sorok egyetlen numerikus indexel rendelkeznk (ugyanakkor
                        t√∂bb indexet is k√©pes kezelni, ha az sz√ºks√©ges), amelyek az index tulajdons√°ggal √©rhet≈ëek el:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.index)
# output: RangeIndex(start=0, stop=1163, step=1)</code></pre>
                    <p class="text-lg font-normal pb-3">Ebben az esetben egy intervallum t√©r√≠t vissza, abb√≥l az okb√≥l kifoly√≥lag,
                        hogy
                        nagyon hossz√∫ JSON √°llom√°nyunk van. R√∂videbb eset√©ben ak√°r egy <em>Int64Index([0, 1, 2, ...],
                            dtype='int64')</em> t√©r√≠tett volna vissza. Tov√°bb√°, ahogy eg√©sz sz√°mok, a sorindexek ak√°r stringek is
                        lehetn√©nek, <em>DatetimeIndices</em> vagy <em>PeriodIndices</em> id≈ë-alap√∫ adatok eset√©n, stb.</p>
                    <p class="text-lg font-normal">Gyakran ak√°r az is megt√∂rt√©nhet, hogy ahhoz, hogy egyszer≈±s√≠ts√ºk √©s sz≈±k√≠ts√ºk a
                        keres√©st az egyik oszlopot be√°ll√≠tjuk a DataFrame indexek√©nt, a <em>set_index</em> met√≥dus √°ltal:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># haszn√°ljuk a set_index met√≥dust, hogy be√°ll√≠tsuk a DataFrame index√©t a 'name' oszlopra,
df = df.set_index('name')
# majd haszn√°ljuk a loc met√≥dust, hogy kiv√°lasszunk sorokat, amelyek tartalmazz√°k a megadott elemet
print(df.loc['Albert Einstein'])
# v√©g√ºl, haszn√°lva a reset_index met√≥dust vissza√°ll√≠tjuk az eredeti √°llapot√°ba
df = df.reset_index()</code></pre>
                    <p class="text-lg font-normal pb-3">A DataFrame sorai √©s oszlopai <em>Pandas Series-k√©nt</em> vannak t√°rolva,
                        a
                        NumPy t√∂mbjeinek heterog√©n megfelel≈ëje. Ezek alapjaiban c√≠mk√©zett egy-dimenzi√≥s t√∂mb√∂k, amelyek b√°rmilyen
                        adatt√≠pust k√©pesek t√°rolni, legyen az elemi vagy √∂sszetett.</p>
                    <p class="text-lg font-normal">H√°rom m√≥d van arra, hogy kiv√°lasszunk egy sort egy DataFrame-b≈ël. Az el≈ëbb
                        l√°thattuk a <em>loc</em> met√≥dust, amely a megadott c√≠mke szerint v√°laszt ki elemeket. L√©tezik az
                        <em>iloc</em> met√≥dus, amely poz√≠ci√≥ szerint v√°laszt ki:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># kiv√°lasztja a met√≥dus a m√°sodik sort, amely a head eset√©n lenne a m√°sodik
print(df.iloc[2])</code></pre>
                    <p class="text-lg font-normal pb-3">V√©g√ºl, van egy <em>ix</em> met√≥dus is, amely √∂tv√∂zi a c√≠mk√©zett el√©r√©st a
                        poz√≠ci√≥ szerinti el√©r√©ssel. Alapvet≈ëen, az ix a c√≠mk√©zett el√©r√©st helyezi fontoss√°gi sorrend szerinti els≈ë
                        helyre, de m√°sodik megold√°sk√©nt mindig az eg√©sz sz√°m√∫ poz√≠ci√≥ szerinti el√©r√©sre t√©r vissza, amennyiben
                        eg√©sz sz√°mmal haszn√°ljuk a met√≥dust, illet≈ëleg a tengely, jelen esetben a 'names' oszlop, nem egy eg√©sz
                        sz√°m. Azonban, a k√©t√©rtelm≈±s√©ge miatt √∫jabb Pandas csomagokban m√°r nem √©l a met√≥dus, √©s kiz√°r√≥lag a loc √©s
                        iloc met√≥dusokkal lehet sorokat el√©rni.</p>
                    <p class="text-lg font-normal">√Ått√©rve az oszlopokra, k√©pesek vagyunk egy teljes oszlopot kiv√°lasztani a
                        DataFrame-b√≥l a megszokott pontos jel√∂l√©st haszn√°lva, vagy ak√°r haszn√°lva a hagyom√°nyos t√∂mb-szer≈±
                        jel√∂l√©st is:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">name_col = df.name # == df['name']
print(type(name_col))
print(name_col)

''' &#60;class 'pandas.core.series.Series'>
0                            Howard Florey
1              Sir Frank Macfarlane Burnet
2                   William Lawrence Bragg
3                         C√©sar Milstein *
4                        John Carew Eccles
                       ...
1158                         Albert Claude
1159    International Atomic Energy Agency
1160                          Peter Handke
1161                     Corneille Heymans
1162                      Elfriede Jelinek
Name: name, Length: 1163, dtype: object '''</code></pre>
                    <p class="text-lg font-normal pb-3">Tov√°bb√°, sz√°mos megk√∂zel√≠t√©s van arra is, hogy csoportokat (val√≥j√°ban
                        sorok
                        csoportjait) v√°lasszunk ki a DataFrame-√ºnkb≈ël, visszat√©r√≠tve egy √∫j, m√°r sz≈±rt DataFrame-t. Gyakran ki
                        szeretn√©nk v√°lasztani azokat a sorokat, amely tartalmaznak egy bizonyos oszlop √©rt√©ket, p√©ldaul
                        kiszeretn√©nk v√°lasztani a fizikai Nobel-d√≠jt nyert szem√©lyeket.</p>
                    <p class="text-lg font-normal">Az egyik megk√∂zel√≠t√©s lenne a DataFrame <em>groupby</em> met√≥dusa, amely
                        kiv√°laszt egy oszlopot, majd haszn√°lhatn√°nk ezen a DataFrame-n a <em>get_group</em> met√≥dust, amely
                        kiv√°lasztan√° az √©rdekelt csoportot:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># kiv√°lasztjuk a kateg√≥ria oszlopot
df = df.groupby('category')
print(df.groups.keys())
# output: dict_keys(['', 'Chemistry', 'Economics', 'Literature', 'Peace', 'Physics', 'Physiology or Medicine'])
# az√©rt van egy √ºres kateg√≥ria is, mert el√≠rt√°k a Wikip√©dia oldalon, √©s nem egys√©ges a jel√∂l√©s

# lek√©rj√ºk, majd ki√≠rjuk a fizikai Nobel-d√≠j gy≈ëzteseket
phy_group = df.get_group('Physics')
print(phy_group.head())</code></pre>
                    <p class="text-lg font-normal">A m√°sodik megk√∂zel√≠t√©st egy √∫n. boolean mask-ot haszn√°l ahhoz, hogy l√©trehozzon
                        egy √∫j DataFrame-t. K√©pesek vagyunk egy boolean oper√°tort haszn√°lni az √∂sszes oszlopon egy DataFrame-ben,
                        pontosan olyan m√≥don ahogyan azt egy NumPy t√∂mb eset√©n is tehetn√©nk:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df.category == 'Physics')

''' output: 
0       False
1       False
2        True
3       False
4       False
        ...
1158    False
1159    False
1160    False
1161    False
1162    False '''</code></pre>
                    <p class="text-lg font-normal">A haszn√°lt boolean mask-ot majd haszn√°lhatjuk az eredeti DataFrame-n, hogy
                        kiv√°lasszuk a sorainak egy alcsoportj√°t:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(df[df.category == 'Physics'])

''' output:
                                                   link  ...                                               text
2     http://en.wikipedia.org/wiki/William_Lawrence_...  ...             William Lawrence Bragg , Physics, 1915
6            http://en.wikipedia.org/wiki/Brian_Schmidt  ...  Brian Schmidt ,  born in the United States , P...
17    http://en.wikipedia.org/wiki/Erwin_Schr%C3%B6d...  ...                  Erwin Schr√∂dinger , Physics, 1933
18     http://en.wikipedia.org/wiki/Victor_Francis_Hess  ...                Victor Francis Hess , Physics, 1936
27          http://en.wikipedia.org/wiki/Wolfgang_Pauli  ...                     Wolfgang Pauli , Physics, 1945
...                                                 ...  ...                                                ...
1131         http://en.wikipedia.org/wiki/Brian_Schmidt  ...  Brian Schmidt ,  born in the United States , P...
1147      http://en.wikipedia.org/wiki/Donna_Strickland  ...                   Donna Strickland , Physics, 2018
1149  http://en.wikipedia.org/wiki/William_Lawrence_...  ...             William Lawrence Bragg , Physics, 1915
1151    http://en.wikipedia.org/wiki/Arthur_B._McDonald  ...                 Arthur B. McDonald , Physics, 2015
1156  http://en.wikipedia.org/wiki/Fran%C3%A7ois_Eng...  ...                   Fran√ßois Englert , Physics, 2013 '''</code></pre>
                    <p class="text-lg font-normal pb-3">Sz√°mos tov√°bbi p√©ld√°t fogunk m√©g l√°tni arra, hogy hogyan tudunk adatokat
                        kiv√°lasztani, ugyanakkor el≈ësz√∂r azzal fogunk m√©g jobban megismerkedni, hogy hogyan tudunk l√©trehozni
                        DataFrame-eket l√©tez≈ë adatokb√≥l √©s hogyan tudjuk lementeni a DataFrame kezel√©sek eredm√©nyeit.</p>
                    <p class="text-lg font-normal pb-3">A legk√∂nnyebb m√≥d arra, hogy l√©trehozzunk egy DataFrame-t az, hogy Python
                        dict-et haszn√°lunk. Ugyanakkor, √©rtelemszer≈±en ez lesz az a m√≥d is, amit a legkev√©sb√© fogunk haszn√°lni,
                        hiszen az esetek t√∂bbs√©g√©ben vagy f√°jlokb√≥l vagy adatb√°zisb√≥l fog sz√°rmazni az adatunk.</p>
                    <p class="text-lg font-normal">Alap√©rtelmezetten, meghat√°rozzuk az oszlopokat k√ºl√∂n, a k√∂vetkez≈ë p√©lda ezt
                        szeml√©lteti, amelyben l√©trehozunk egy 3 soros t√°bl√°zatot 'name' √©s 'category' oszlopokkal:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = pd.DataFrame({
    'name': ['Albert Einstein', 'Marie Curie', 'William Faulkner'],
    'category': ['Physics', 'Chemistry', 'Literature']
})

print(df.head())
''' output:
               name    category
0   Albert Einstein     Physics
1       Marie Curie   Chemistry
2  William Faulkner  Literature '''</code></pre>
                    <p class="text-lg font-normal">Tov√°bb√°, a fenti p√©ld√°hoz nagyban hasonl√≥an k√©pesek vagyunk az
                        <em>from_dict</em> met√≥dust haszn√°lni, hogy rekord-alap√∫ (record based) l√©trehoz√°shoz, amikor is egy t√∂mb
                        dict-et adunk meg, amelyben mindenik egy √∫jabb rekord √©s egy √∫jabb sort jel√∂l a DataFrame-√ºnkben. A
                        from_dict rendelkezik egy <em>orient</em>
                        argumentummal is, amely lehet≈ëv√© teszi, hogy meghat√°rozzuk a rekord t√≠pus√∫ adatunkat √©s annak form√°j√°t, de
                        a Pandas ez okosan, mag√°t√≥l is k√©pes kik√∂vetkeztetni az adatb√≥l:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = pd.DataFrame.from_dict([
    {'name': 'Albert Einstein', 'category': 'Physics'},
    {'name': 'Marie Curie', 'category': 'Chemistry'},
    {'name': 'William Faulkner', 'category': 'Literature'}
])

print(df.head())
''' output:
               name    category
0   Albert Einstein     Physics
1       Marie Curie   Chemistry
2  William Faulkner  Literature '''</code></pre>
                    <p class="text-lg font-normal pb-3">Mivel eml√≠tett√ºk, hogy nem igaz√°n fogjuk valaha is haszn√°lni a fenti
                        megold√°sokat, t√©rj√ºnk is r√° a l√©nyegre, a f√°jlb√≥l/adatb√°zisb√≥l t√∂rt√©n≈ë beolvas√°sra. A Pandas rengeteg
                        <em>read_[form√°tum]/to_[form√°tum]</em> met√≥dussal rendelkezik, amelyek lefedik a legt≈ëbb elk√©pzelhet≈ë
                        adat-beolvas√°si esetet, eg√©szen CSV f√°jlokt√≥l kezdve a bin√°ris HDF5 form√°tumon kereszt√ºl, az SQL
                        adatb√°zisokig. A mi munk√°nkhoz elengedhetetlen eseteket a tov√°bbiakban meg is vizsg√°ljuk.</p>
                    <p class="text-lg font-normal pb-3">Fontos azt is megjegyezni, hogy alap√©rtelmezetten a Pandas megpr√≥b√°lja
                        n√©mik√©pp finoman √°talak√≠tani a beolvasott adatokat. A legt√∂bb beolvas√°si met√≥dus opci√≥kkal rendelkezik,
                        mint p√©ld√°ul a <em>convert_axes</em>, amely megpr√≥b√°lja √°talak√≠tani a tengelyeket megfelel≈ë dtype-okk√°,
                        <em>dtype</em>, illetve a <em>convert_dates</em> is mind Igazra van √°ll√≠tva.</p>
                    <p class="text-lg font-normal pb-3">El≈ësz√∂ris, figyelj√ºk meg azokat az eseteket, amikor f√°jlalap√∫ beolvas√°sr√≥l
                        van sz√≥.</p>
                    <p class="text-lg font-normal">Kor√°bban m√°r l√°thattuk azt, hogyan k√©pes a Pandas JSON √°llom√°nyb√≥l l√©trehozni
                        DataFrame-eket:</p>
                    <pre
                        class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')</code></pre>
                    <p class="text-lg font-normal pb-3">Ugyanakkor, a JSON √°llom√°ny is sz√°mos form√°t felvehet, meghat√°rozva egy
                        opcion√°lis orient argumentummal, az orient a k√∂vetkez≈ë √©rt√©kek valamelyik√©t veheti fel: [split, records,
                        index, columns, values]. Mint mondtuk k√©pes a Pandas √∂nmag√°t√≥l is kik√∂vetkeztetni a megfelel≈ë orient-et,
                        de alap√©rtelmezetten az oszlopos form√°t haszn√°lja. A mi eset√ºnkben a JSON √°llom√°nyunkban tal√°lhat√≥
                        rekord-alap√∫t fogjuk haszn√°lni, hiszen a web-alap√∫ adat-vizualiz√°ci√≥hoz, f≈ëk√©pp a D3-hoz, ez a
                        legmegfelel≈ëbb √©s leggyakoribb megk√∂zel√≠t√©s a t√°bl√°zatos adat √°tad√°s√°hoz.</p>
                    <p class="text-lg font-normal">Sz√°mos m√≥d van arra is, hogy DataFrame-eket JSON-okk√° alak√≠tsunk √°t, ami a
                        form√°tumot illeti (orient√°ci√≥t), ahhoz, hogy a fent eml√≠tett rekord-alap√∫ JSON √°llom√°nyt kapjuk meg a
                        DataFrame-b≈ël a k√∂vetkez≈ët kell √≠rnunk:</p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')

# elv√©gezz√ºk a sz√ºks√©ges m≈±veletek a df-en ...

json = df.to_json('./nobel_prize/nobel_winners/nobel_winners/nwinners_cleaned.json', orient='records')</code></pre>
                    <p class="text-lg font-normal pb-3">Rendelkez√©s√ºnkre √°llnak a <em>date_format</em>, <em>double_precision</em>,
                        <em>default_handler</em> param√©terek is, ha az objektum nem alak√≠that√≥ √°t JSON-n√° a Pandas parser-√©vel.
                    </p>
                    <p class="text-lg font-normal">A m√°sodik gyakori t√≠pus nem m√°s, mint a CSV f√°jlok. A Pandas CSV f√°jl-kezel√©se
                        annyira kifinomult, hogy szinte a lehet≈ë legt√∂bb elk√©pzelhet≈ë adattal k√©pes elb√°nni ebben a form√°tumban. A
                        konvencion√°lis CSV f√°jlok, a nagy t√∂bbs√©g ilyen, b√°rmif√©le param√©ter n√©lk√ºl k√©pesek bet√∂lteni:
                    </p>
                    <pre
                        class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = pd.read_csv('nobel_winners.csv')</code></pre>
                    <p class="text-lg font-normal">Ugyanakkor, sz√°mos CSV forma van, ami nem vessz≈ëvel van elv√°lasztva, vagy
                        saj√°tos, a szok√°sost√≥l elt√©r≈ë id√©z≈ëjelez√©st haszn√°l olyan stringek eset√©n, amelyek sz√≥k√∂zt vagy speci√°lis
                        karaktereket tartalmaznak. Ilyen esetekben k√©pesek vagyunk b√°rmilyen egy√©ni elemet meghat√°rozni az
                        olvas√°si lek√©rdez√©s√ºnkben, a p√©ld√°nkban haszn√°lva a Python hasznos <em>StringIO</em> m√≥dul√°t, hogy
                        ut√°nozzuk a f√°jlb√≥l val√≥ beolvas√°st:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">from io import StringIO

data = " `Albert Einstein`| Physics \n`Marie Curie`| Chemistry"

# meghat√°rozzuk a szok√°sost√≥l elt√©r≈ë jel√∂l√©seket, mint a mez≈ë elv√°laszt√≥ |-t, a kateg√≥ri√°k neveit, 
# a kezdeti space kihagy√°s√°t, √©s azt a jel√∂l√©si m√≥dot, ahogy a sz√≥k√∂zt tartalmaz√≥ stringek vannak jel√∂lve
df = pd.read_csv(StringIO(data), sep='|', names=['name', 'category'], skipinitialspace=True, quotechar="`")

print(df.head())
''' output:
              name   category
0  Albert Einstein   Physics
1      Marie Curie  Chemistry '''</code></pre>
                    <p class="text-lg font-normal">K√©pesek vagyunk a JSON-hoz hasonl√≥an DataFrame-t CSV f√°jll√° is alak√≠tani a
                        k√∂vetkez≈ëk√©ppen:
                    </p>
                    <pre
                        class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">csv = df.to_csv('data.csv', encoding='utf-8')</code></pre>
                    <p class="text-lg font-normal">√Ått√©rve az Excel f√°jlokra, a Pandas a Python <em>xlrd</em> m√≥dulj√°t haszn√°lja,
                        hogy olvasson egyar√°nt .xls, √©s .xls f√°jlokb√≥l. Az Excel dokumentumoknak ak√°r t√∂bb elnevezett munkalapja
                        is lehet, amelyek mindegyik DataFrame-√© alak√≠that√≥. K√©t m√≥d van arra, hogy egy munkalapot beolvassunk
                        DataFrame-√©. Az els≈ë megk√∂zel√≠t√©s szerint l√©trehozunk majd elemz√ºnk egy ExcelFile objektumot:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">dfs = {}
xls = pd.ExcelFile('nobel_winners.xlsx') # bet√∂lti az Excel f√°jlt
# fogja a munkalapot n√©v szerint, √©s lementi egy dict-be
dfs['WSheet1'] = xls.parse('WinnersSheet1', na_values = ['NA'])
# ugyan√∫gy, azonban ebben az esetben meghat√°rozzuk el≈ësz√∂ris az oszlopot, poz√≠ci√≥ szerint, hogy haszn√°ljuk, mint a DataFrame sorc√≠mk√©i
# az na_values eset√©ben meghat√°rozzuk azon stringeket, amelyeket NaN-k√©nt kell √©rtelmezzen
# v√©g√ºl a skiprows eset√©ben a sorok sz√°m√°t hat√°rozzuk meg, amelyeket kikell hagyjon feldolgoz√°s el≈ëtt, pl. metaadat lenne ezekben
dfs['WSheet2'] = xls.parse('WinnersSheet2', index_col=0, na_values=['-'], skiprows=3)</code></pre>
                    <p class="text-lg font-normal">Alternat√≠van, k√©pesek vagyunk a <em>read_excel</em> met√≥dust is haszn√°lni,
                        amely egy k√©nyelmesebb megold√°s t√∂bb munkalap beolvas√°s√°ra:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># ebben az esetben a m√°sodik munkalap rosszul form√°zotts√°ga miatt nem megfelel≈ëen olvassa be
data = pd.read_excel('nobel_winners.xlsx', ['WinnersSheet1', 'WinnersSheet2'], index_col=None, na_values = ['NA'])</code></pre>
                    <p class="text-lg font-normal pb-3">Az egyetlen ok ami miatt nem lenne haszn√°lhat√≥ a read_excel met√≥dus az az
                        amikor k√ºl√∂nb√∂z≈ë argumentumokkal szeretn√©nk beolvasni mindenik Excel munkalapot, ahogy azt az els≈ë
                        p√©ld√°ban is l√°thattunk, illet≈ëleg, amely n√©lk√ºl a m√°sodik p√©ld√°ban nem megfelel≈ëen fogja a rosszul
                        form√°zotts√°ga miatt a m√°sodikat helyesen beolvasni.
                    </p>
                    <p class="text-lg font-normal">A read_excel met√≥dus eset√©ben nagyon sok param√©ter √°ll rendelkez√©s√ºnkre,
                        p√©ld√°ul, ha csak az Excel f√°jl nev√©t adjuk meg, abban az esetben csak az els≈ë munkalapot olvassa be, ha
                        None-ra, abban az esetben az √∂sszeset:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">data = pd.read_excel('nobel_winners.xlsx')

data = pd.read_excel('nobel_winners.xlsx', None) # == sheetname=None</code></pre>
                    <p class="text-lg font-normal">A <em>usecols</em> param√©ter pedig lehet≈ës√©get ny√∫jt arra, hogy kiv√°lasszuk
                        azokat az oszlopokat, amelyeket szeretn√©nk √©rtelmezni √©s beolvasni. A usecols-t t√∂bb form√°tumban is
                        megadhatjuk, a legegyszer≈±bb, ha Excel st√≠lusban adjuk meg ahogy azt a p√©lda is mutatja, de ak√°r egy
                        list√°nyi eg√©sz sz√°mot is megadhatunk, jel√∂lve azokat az oszlopokat, amelyeket beolvasn√°nk:
                    </p>
                    <pre
                        class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">data = pd.read_excel('nobel_winners.xlsx', 'WinnersSheet1', index_col=0, usecols='A:C')</code></pre>
                    <p class="text-lg font-normal">Most az √©rdekesebb r√©szt k√©pesek vagyunk DataFrame-ket is, az el≈ëz≈ë p√©ld√°khoz
                        hasonl√≥an, Excel f√°jlok munkalapjaik√©nt lementeni a <em>to_excel</em> met√≥dussal, megadva az Excel
                        f√°jlnev√©t √©s a munkalapnev√©t:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')

# lementi a DataFrame √©rt√©keit a nobel_winners Excel f√°jlba, l√©trehozva egy √∫j munkalapot WinnersSheet3 n√©ven
# fontos megjegyezni azt, hogy teljesen √∫j Excel f√°jlt hoz l√©tre, t√∂r√∂lve a m√°r l√©tez≈ë munkalapokat
excel = df.to_excel('nobel_winners.xlsx', sheet_name='WinnersSheet3')</code></pre>
                    <p class="text-lg font-normal">Illet≈ëleg, megt√∂rt√©nhet az is, hogy t√∂bb DataFrame-t szeretn√©nk ki√≠rni egy
                        megosztott Excel f√°jlba, azt valahogy √≠gy tenn√©nk:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">df1 = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')
df2 = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/minibios.json')

# ebben az esetben mindk√©t DataFrame-t ugyanabba az Excel f√°jlba fogja √≠rni
with pd.ExcelWriter('nobel_winners.xlsx') as writer:
    df1.to_excel(writer, sheet_name='WinnersSheet')
    df2.to_excel(writer, sheet_name='WinnersBios')</code></pre>
                    <p class="text-lg font-normal pb-3">√Ått√©rve, f√°jlalap√∫ adatt√°rol√°sr√≥l, adatb√°zis alap√∫ra, a Pandas, ha
                        lehets√©ges,
                        a Python SQLAlchemy m√≥dulj√°t haszn√°lja az adatb√°zis absztrakci√≥hoz. Amennyiben nem √°ll rendelkez√©sre,
                        fallback-k√©nt az sqlite-ra √©p√ºlve a Python szabv√°ny k√∂nyvt√°rat haszn√°lja. Amennyiben, az SQLAlchemy-t
                        haszn√°lod abban az esetben azt is import√°lnod kell.
                    </p>
                    <p class="text-lg font-normal">A legk√∂nnyebb megold√°s arra, hogy egy adatb√°zis t√°bl√°t, vagy SQL lek√©rdez√©s
                        eredm√©ny√©t DataFrame-be olvassuk az <em>read_sql</em> met√≥dus:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># emellett sz√ºks√©g volt a pymysql m√≥dul telep√≠t√©s√©re is pip-el
import sqlalchemy

# el≈ësz√∂ris, l√©trehozzuk a t√°rol√≥motrot, megadva az adatb√°zis el√©r√©s√©t, illet≈ëleg annak nev√©t
engine = sqlalchemy.create_engine('mysql+pymysql://root@localhost/nobel_prize')

# megadjuk els≈ë argumentumk√©nt a beolvasand√≥ SQL t√°bla nev√©t, majd a t√°rol√≥motrot
df = pd.read_sql('nobel_winners', engine)</code></pre>
                    <p class="text-lg font-normal">DataFrame-ket SQL adatb√°zisba √≠rni is legal√°bb ennyire egyszer≈±, felhaszn√°lva
                        az el≈ëbb l√©trehozott t√°rol√≥motrunkat:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># beolvassuk a JSON √°llom√°nyt, amelyet kiszeretn√©nk √≠rni
df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')
# ki√≠rjuk az adatb√°zisba, az els≈ë argumentumban meghat√°rozva az SQL t√°bla nev√©t, 
# megadva a t√°rol√≥motrot, illet≈ëleg 500-as chunkokban, sorokban, fogja ki√≠rni
df.to_sql('nobel_winners', engine, chunksize=500)</code></pre>
                    <p class="text-lg font-normal">Fontos megeml√≠teni azt, hogy a Pandas megpr√≥b√°lja finoman kik√∂vetkeztetni az
                        adatunkb√≥l, hogy milyen SQL adatt√≠pus felelnek meg neki, ha sz√ºks√©ges ak√°r ezt magunk is megadhatjuk a
                        k√∂vetkez≈ëk√©ppen:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">from sqlalchemy.types import String

df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')
# mivel a VARCHAR t√≠pust haszn√°lja, ez√©rt megkell adni a hosszt is
df.to_sql('nobel_winners', engine, dtype={'year': String(4)})</code></pre>
                    <p class="text-lg font-normal pb-3">V√©g√ºl, az adat-vizualiz√°ci√≥s munka sor√°n sokat lehetne mes√©lni a
                        dokumentum-alap√∫ NoSQL adatb√°zisok √°ltal ny√∫jtott k√©nyelemr≈ël, ilyen p√©ld√°ul a m√°r kor√°bban eml√≠tett
                        MongoDB. A MongoDB-vel
                        kicsit m√©g jobb a helyzet, hiszen a JSON bin√°ris form√°j√°t haszn√°lja adatt√°rol√≥k√©nt, n√©vszerint a BSON-t.
                        Mivel a JSON ami adat-ragaszt√≥nk, hiszen √∂sszekapcsolja a webes vizualiz√°ci√≥s dolgainkat a backend
                        szerverrel, el√©g j√≥ d√∂nt√©snek t≈±nik az, ha Mongo-n t√°roljuk az adatsorainkat. V√©g√ºl, az sem elhagyhat√≥,
                        hogy el√©g k√∂nnyen kezelhet≈ë egy√ºtt a Pandas-al.
                    </p>
                    <p class="text-lg font-normal">Ahogy azt kor√°bban is l√°thattuk, nagyon egyszer≈±en k√©pesek a Pandas
                        DataFrame-jei JSON form√°tumba alakulni, vagy JSON form√°tumb√≥l beolvas√≥dni, teh√°t egy Mongo dokumentum
                        collection nagyon egyszer≈±en √°talak√≠that√≥ DataFrame-√©:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">from pymongo import MongoClient

# l√©trehozunk egy Mongo klienst, az alap√©rtelmezetten host-al √©s port-al
client = MongoClient()

# lek√©rj√ºk a nobel_prize adatb√°zist
db = client.nobel_prize
# megkeresi az √∂sszes dokumentumot a winners collection-√∂n bel√ºl
cursor = db.winners.find()
# beolvassa az √∂sszes dokumentumot a winners collection-√∂n bel√ºl listak√©nt, hogy l√©trehozza a DataFrame-t
df = pd.DataFrame(list(cursor))</code></pre>
                    <p class="text-lg font-normal">Azt√°n legal√°bb ennyire egyszer≈± DataFrame-ket MongoDB adatb√°zisba √≠rni, amelyet
                        a k√∂vetkez≈ë k√≥dr√©szlet szeml√©ltet:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># alap√©rtelmezett be√°ll√≠t√°sokkal, csup√°n az adatb√°zisn√©v tetsz≈ëleges
def get_mongo_database(db_name, host='localhost', port=27017, username=None, password=None):
    """ El√©rj√ºk a db_name-mel hivatkozott adatb√°zist MongoDB-r≈ël, hiteles√≠t≈ë adatokkal vagy azok n√©lk√ºl """

    if username and password:
        mongo_uri = 'mongodb://{}:{}@{}/{}'.format(username, password, host, db_name)
        # URI = uniform resource identifier
        conn = MongoClient(mongo_uri)
    else:
        conn = MongoClient(host, port)

    return conn[db_name] # itt m√°r a m√°sodik f√©le jel√∂l√©st haszn√°ljuk az adatb√°zis el√©r√©s√©hez

# felhaszn√°lva a kor√°bban l√©trehozott f√ºggv√©ny√ºnket el√©rj√ºk az adatb√°zist

db = get_mongo_database('nobel_prize')

df = pd.read_json('./nobel_prize/nobel_winners/nobel_winners/nwinners.json')
records = df.to_dict(orient='records')
db['nwinners_full'].insert_many(records)</code></pre>
                    <p class="text-lg font-normal">A k√∂vetkez≈ëkben √≠rjunk n√©h√°ny hasznos kicsi f√ºggv√©nyt, amely megk√∂nny√≠ti, hogy
                        DataFrame-t √≠rjunk √©s olvassunk egy MongoDB adatb√°zisba/adatb√°zisb√≥l:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">def mongo_to_dataframe(db_name, collection, query={}, host='localhost', port=27017, username=None, password=None, no_id=True):
    """ L√©trehoz egy DataFrame-t egy MongoDB collection-b√≥l """

    db = get_mongo_database(db_name, host, port, username, password)

    # megkeresi a collection-b√≥l a lek√©rdez√©s szerinti elemeket
    cursor = db[collection].find(query)

    df = pd.DataFrame(list(cursor))

    # amennyiben azt szeretn√©nk, hogy t√∂r√∂lje ki a MongoDB √°ltal hozz√°adott id-t
    if no_id:
        del df['_id']

    return df

def dataframe_to_mongo(df, db_name, collection, host='localhost', port=27017, username=None, password=None):
    """ Lement egy DataFrame-t egy MongoDB collection-be """

    db = get_mongo_database(db_name, host, port, username, password)

    records = df.to_dict(orient='records')

    db[collection].insert_many(records)</code></pre>
                    <p class="text-lg font-normal pb-3">Egy k√∂vetkez≈ë m√≥d arra, hogy DataFrame-ket hozzunk l√©tre az az, hogy
                        fel√©p√≠tj√ºk ≈ëket <em>Series</em>-ek egy kollekci√≥j√°b√≥l. A k√∂vetkez≈ëkben a Series-t fogjuk k√∂nny≈±
                        r√©szleteiben
                        megismerni.
                    </p>
                    <p class="text-lg font-normal pb-3">A Pandas Series-ei m√∂g√∂tti kulcsgondolat az indexei. Ezek az indexek
                        c√≠mk√©kk√©nt
                        funkcion√°lnak azoknak a heterog√©n adatoknak, amelyek az adatok soraiban tal√°lhat√≥k. Amikor a Pandas t√∂bb,
                        mint egy adat objektumon dolgozik, akkor ezek az indexek vannak felhaszn√°lva, hogy helyreigaz√≠ts√°k a
                        mez≈ëket.
                    </p>
                    <p class="text-lg font-normal">Series-t h√°romf√©lek√©ppen tudunk l√©trehozni. El≈ësz√∂r, k√©pesek vagyunk
                        Python list√°b√≥l vagy NumPy t√∂mbb√∂l l√©trehozni:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">import numpy as np

s = pd.Series(np.arange(1, 5)) # == pd.Series([1, 2, 3, 4])
print(s)

''' output:
0    1  # index, value
1    2
2    3
3    4
dtype: int32 '''</code></pre>
                    <p class="text-lg font-normal">Megjegyezend≈ë dolog, hogy az eg√©sz √©rt√©k≈± indexek automatikusan ker√ºlnek
                        l√©trehoz√°sra a Series-√ºnkh√∂z. Ha egy sornyi adatot adn√°nk hozz√° egy DataFrame-hez √©s mi szeretn√©nk
                        meghat√°rozni azok indexeit, abban az esetben megtehetj√ºk azt az √°ltal, hogy beadunk egy list√°nyi eg√©sz
                        sz√°mot vagy valamilyen c√≠mk√©t a k√∂vetkez≈ëk√©ppen:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">s = pd.Series([1, 2, 3, 4], index=['a', 'b', 'c', 'd'])
print(s)

''' output:
a    1
b    2
c    3
d    4
dtype: int64 '''</code></pre>
                    <p class="text-lg font-normal">A fenti esetben fontos megjegyezni azt is, hogy az index t√∂mb hossza, megkell
                        egyezzen az adatokat tartalmaz√≥ t√∂mb hossz√°val. A fenti esetet leegyszer≈±s√≠tve haszn√°lhatjuk a Series-ek
                        l√©trehoz√°s√°ra a Python dict-ekkel t√∂rt√©n≈ë megold√°st is a k√∂vetkez≈ëk√©ppen, amikor egyszerre tudjuk az
                        indexet, illet≈ëleg az adatsort is meghat√°rozni:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">s = pd.Series({'a': 1, 'b': 2, 'c':3, 'd':4 })
print(s)

''' output:
a    1
b    2
c    3
d    4
dtype: int64 '''</code></pre>
                    <p class="text-lg font-normal">Abban az esetben, ha a dict-es megk√∂zel√≠t√©s eset√©n egy indexeket tartalmaz√≥
                        t√∂mb√∂t is beadunk a met√≥dusba, a Pandas nagyon √©rthet≈ë m√≥don megpr√≥b√°lja p√°ros√≠tani az indexeket az
                        adatsorhoz, minden olyan index esetet, amelyet nem tud p√°ros√≠tani, az adotthoz indexhez NaN-t rendel, ha
                        egy adott √©rt√©khez az adatsorban nem tartozik index az index t√∂mbb√∂l elveti:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">s = pd.Series({'a': 1, 'b': 2, 'd': 4}, index=['a', 'b', 'c'])
print(s)

''' output:
a    1.0
b    2.0
c    NaN
dtype: float64 '''</code></pre>
                    <p class="text-lg font-normal">V√©g√ºl, k√©pesek vagyunk egyetlen skal√°ris (egyszer≈± numerikus √©rt√©k) √©rt√©ket
                        √°tadni, mint adat a Series-nek, adva, hogy az indexeket meghat√°rozzuk, ebben az esetben az √∂sszes
                        meghat√°rozott indexhez az adott skal√°ris √©rt√©ket rendeli hozz√°:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">s = pd.Series(9, index=[1, 2, 3])
print(s)

''' output:
1    9
2    9
3    9
dtype: int64 '''</code></pre>
                    <p class="text-lg font-normal">A Series-ek √∫gy m≈±k√∂dnek, mint a NumPy t√∂mb√∂k (ndarray), ami azt eredm√©nyezi,
                        hogy a legt√∂bb NumPy f√ºggv√©nnyel haszn√°lhat√≥k:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">import numpy as np

s = pd.Series(np.arange(1, 5), index=['a', 'b', 'c', 'd'])
s = np.sqrt(s)
print(s)

''' output:
a    1.000000
b    1.414214
c    1.732051
d    2.000000
dtype: float64 '''</code></pre>
                    <p class="text-lg font-normal">K√∂vetkez≈ë √©rdekess√©g, hogy a slicing oper√°torok is ugyan√∫gy m≈±k√∂dnek,
                        mintha csak NumPy t√∂mb√∂ket, vagy Python list√°kat haszn√°ln√°nk:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(s[1:3])

''' output:
b    1.414214
c    1.732051
dtype: float64 '''</code></pre>
                    <p class="text-lg font-normal">A Series legnagyobb el≈ënye a NumPy t√∂mb√∂kkel szemben, ahogy az a bevezet≈ëbe is
                        eml√≠tve volt, hogy t√∂bbf√©le adatt√≠pust is nagyszer≈±en kezel:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python">print(pd.Series([6, 3.2, 'foo']) + pd.Series([3, 0.8, 'bar']))

''' output:
0         9
1         4
2    foobar
dtype: object '''</code></pre>
                    <p class="text-lg font-normal">Mivel a DataFrame-k √©pit≈ëkock√°inak az iment megismert Series-ek sz√°m√≠tanak, nem
                        t√∫l bonyol√∫lt feladat √∂sszes√≠teni ezeket l√©trehozva DataFrame-ket, felhaszn√°lva a Pandas <em>concat</em>
                        met√≥dus√°t:
                    </p>
                    <pre class="my-4 text-sm md:text-md font-semibold rounded-md overflow-auto text-gray-200"><code class="python"># a name argumentummal egyszer≈±en meghat√°rozok a Series nev√©t, amely k√©s≈ëbb az oszlopn√©v lesz
names = pd.Series(['Albert Einstein', 'Marie Curie'], name='name')
categories = pd.Series(['Physics', 'Chemistry'], name='category')

# az axis=1 √°ltal "v√≠zszintesre" √°ll√≠tjuk az √∂sszes√≠t√©st, azaz azt hat√°rozzuk meg, hogy a Series-ek oszlopok
df = pd.concat([names, categories], axis=1)
print(df.head())

''' output:
              name   category
0  Albert Einstein    Physics
1      Marie Curie  Chemistry '''</code></pre>
                    <p class="text-lg font-normal">V√©g√ºl, pedig az utols√≥ bevezet≈ë dologr√≥l kell besz√©ln√ºnk, ami nem m√°s,
                        mint a
                        Pandas <em>Panel</em>. A Panel class l√©nyeg√©ben nem m√°s, mint egy kont√©ner t√∂bb DataFrame-hez. Ahogyan a
                        DataFrame l√©nyeg√©ben Series-ekb≈ël √©p√ºl fel, √∫gy a Panel DataFramek-ekb≈ël √©p√ºl fel. A Panel egy √∫jabb
                        dimenzi√≥t ad hozz√° a DataFrame-hez, ez √°ltal mivel a harmadik szintet k√©pviseli, h√°rom-dimenzi√≥s
                        kont√©nerr√© v√°lik. Teh√°t, √∂sszes√©g√©ben az indexeken √©s oszlopokon t√∫l, amelyekkel a DataFrame rendelkezik,
                        biztos√≠t egy √∫jabb tengelyt, amely meghat√°rozza melyik DataFrame-n√©l vagyunk jelenleg. Tov√°bb√°, √©rdemes volt megismerni a koncepci√≥t, de a Pandas leg√∫jabb v√°ltozataiban ez a class m√°r nem √©rhet≈ë el.
                    </p>
                </section>
            </section>

            <!-- negyedik r√©sze v√©ge -->

            <div class="my-8 flex content-center">
                <button class="flex-auto w-24 bg-gray-900 text-white group hover:bg-blue-800 transition duration-75 ease-in"><a
                        class="block px-4 py-2"
                        href="3.html"><span class="inline-block font-normal transform group-hover:-translate-x-1 transition
                            duration-100 ease-in">&larr;</span>
                        El≈ëz≈ë</a></button>
                <!--<button class="flex-auto w-24 ml-4 py-2 bg-gray-900 text-white group hover:bg-blue-800 transition duration-75
                    ease-in"><a class="block px-4"
                        href="#">K√∂vetkez≈ë
                        <span
                            class="inline-block font-normal transform group-hover:translate-x-1 transition duration-100 ease-in">&rarr;</span></a></button>-->
            </div>
        </main>

        <div id="arr"
            class="fixed block transition duration-100 ease-in"><a class="inline-block text-3xl py-3 px-6 hover:text-blue-800 transition duration-100 ease-in transform hover:scale-125
                opacity-50 hover:opacity-100"
                href="#menu">&uarr;</a></div>

        <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
        <script src="https://d3js.org/d3.v5.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.10.2/underscore-min.js"></script>
        <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js"></script>
        <script src="../tools/pushy-1.3.0/js/pushy.min.js"></script>
        <!-- cross-platform megold√°s a smooth-scroll-ra, jQuery haszn√°lat√°val -->
        <script src="../javascript/smooth.js"></script>
        <script src="../javascript/main.js"></script>
        <script src="../javascript/introd3.js"></script>
    </body>

</html>